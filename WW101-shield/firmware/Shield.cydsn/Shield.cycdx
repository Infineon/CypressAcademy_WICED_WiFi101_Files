<?xml version="1.0" encoding="utf-8"?>
<blockRegMap version="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://cypress.com/xsd/cyblockregmap cyblockregmap.xsd" xmlns="http://cypress.com/xsd/cyblockregmap">
  <block name="CBLED2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="CBLED1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="D_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="CBLED3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="D12" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="MB1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="CBLED0" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="LED2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="PWR_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="GND_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="C_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="R_4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="Thermistor" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="UART" BASE="0x0" SIZE="0x0" desc="Serial Communication Block" visible="true" hidden="false">
    <block name="clock_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sclk_s_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="mosi_s_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="rx_wake_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="SCBCLK" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="select_s_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="rx_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="miso_m_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cts_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="SCB" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="Device_VM4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="rx" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="tx" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_7" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="or_sclk" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <register name="_CTRL" address="0x40080000" bitWidth="32" desc="Generic control register" hidden="false">
      <field name="OVS" from="3" to="0" access="RW" resetVal="" desc="Serial interface bit period oversampling factor expressed in lP clock cycles. Used for SPI and UART functionality. OVS + 1 IP clock cycles constitute a single serial interface clock/bit cycle." hidden="false" />
      <field name="EC_AM_MODE" from="8" to="8" access="RW" resetVal="" desc="Internally clocked mode ('0') or externally clocked mode ('1') address matching (I2C) or selection (SPI).In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface." hidden="false" />
      <field name="EC_OP_MODE" from="9" to="9" access="RW" resetVal="" desc="Internally clocked mode ('0') or externally clocked mode ('1') operation. In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface." hidden="false" />
      <field name="EZ_MODE" from="10" to="10" access="RW" resetVal="" desc="Non EZ mode ('0') or EZ mode ('1'). In EZ mode, a meta protocol is applied to the serial interface protocol." hidden="false" />
      <field name="BYTE_MODE" from="11" to="11" access="RW" resetVal="" desc="Determines the number of bits per FIFO data element: '0' - 16-bit FIFO data elements (FIFO entries 8), '1' - 8-bit FIFO data elements (FIFO entries 16). Setting data elemelents to 8-bits doubles the amount of FIFO entries." hidden="false" />
      <field name="ADDR_ACCEPT" from="16" to="16" access="RW" resetVal="" desc="Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').his field is used in the I2C mode." hidden="false" />
      <field name="BLOCK" from="17" to="17" access="RW" resetVal="" desc=" If the externally clocked logic and the MMIO SW accesses to EZ memory coincide/collide, this bit determines whether a SW access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0')" hidden="false" />
      <field name="MODE" from="25" to="24" access="RW" resetVal="" desc="Mode of operation: I2C = 0, SPI = 1, UART = 2" hidden="false" />
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="IP enabled ('1') or not ('0')." hidden="false" />
    </register>
    <register name="_SPI_CTRL" address="0x40080020" bitWidth="32" desc="SPI control register" hidden="false">
      <field name="CONTINUOUS" from="0" to="0" access="RW" resetVal="" desc="Continuous SPI data transfers enabled ('1') or not ('0')." hidden="false" />
      <field name="SELECT_PRECEDE" from="1" to="1" access="RW" resetVal="" desc="Only used in SPI Texas Instruments' submode. When '1', the data frame start indication is a pulse on the SELECT line that precedes the transfer of the first data frame bit. When '0', the data frame start indication is a pulse on the SELECT line that coincides with the transfer of the first data frame bit." hidden="false" />
      <field name="CPHA" from="2" to="2" access="RW" resetVal="" desc="Only applicable in SPI Motorola submode. Indicates the clock phase." hidden="false" />
      <field name="CPOL" from="3" to="3" access="RW" resetVal="" desc="Only applicable in SPI Motorola submode. Indicates the clock polarity." hidden="false" />
      <field name="LATE_MISO_SAMPLE" from="4" to="4" access="RW" resetVal="" desc="Only applicable in master mode. Changes the SCLK edge on which MISO is captured." hidden="false" />
      <field name="SCLK_CONTINUOUS" from="5" to="5" access="RW" resetVal="" desc="Enables SCLK generation continuiusly by master regars data is avaiable in TX FIFO or not." hidden="false" />
      <field name="SSEL_POLARITY0" from="8" to="8" access="RW" resetVal="" desc="Slave select polarity of SS0." hidden="false" />
      <field name="SSEL_POLARITY1" from="9" to="9" access="RW" resetVal="" desc="Slave select polarity of SS1." hidden="false" />
      <field name="SSEL_POLARITY2" from="10" to="10" access="RW" resetVal="" desc="Slave select polarity of SS2." hidden="false" />
      <field name="SSEL_POLARITY3" from="11" to="11" access="RW" resetVal="" desc="Slave select polarity of SS3." hidden="false" />
      <field name="LOOPBACK" from="16" to="16" access="RW" resetVal="" desc="Local loopback control." hidden="false" />
      <field name="MODE" from="25" to="24" access="RW" resetVal="" desc="Submode of SPI operation: Motorola = 0, Texas Instruments = 1, National Semiconducturs = 2." hidden="false" />
      <field name="SLAVE_SELECT" from="27" to="26" access="RW" resetVal="" desc="Selects one of the four SPI slave select signals: SS0 = 0, SS1 = 1 , SS2 = 2, SS3 = 3." hidden="false" />
      <field name="MASTER_MODE" from="31" to="31" access="RW" resetVal="" desc="Master ('1') or slave ('0') mode." hidden="false" />
    </register>
    <register name="_SPI_STATUS" address="0x40080024" bitWidth="32" desc="SPI status register" hidden="false">
      <field name="BUS_BUSY" from="0" to="0" access="R" resetVal="" desc="SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction" hidden="false" />
    </register>
    <register name="_UART_CTRL" address="0x40080040" bitWidth="32" desc="UART control register" hidden="false">
      <field name="LOOPBACK" from="16" to="16" access="RW" resetVal="" desc="Local loopback control." hidden="false" />
      <field name="MODE" from="25" to="24" access="RW" resetVal="" desc="Submode of UART operation: Standard = 0, Smart Card = 1, IrDA = 2." hidden="false" />
    </register>
    <register name="_UART_TX_CTRL" address="0x40080044" bitWidth="32" desc="UART transmitter control register" hidden="false">
      <field name="STOP_BTIS" from="2" to="0" access="RW" resetVal="" desc="Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods." hidden="false" />
      <field name="PARITY" from="4" to="4" access="RW" resetVal="" desc="Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity" hidden="false" />
      <field name="PARITY_ENABLED" from="5" to="5" access="RW" resetVal="" desc="Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware." hidden="false" />
      <field name="RETRY_ON_NACK" from="8" to="8" access="RW" resetVal="" desc="When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode." hidden="false" />
    </register>
    <register name="_UART_RX_CTRL" address="0x40080048" bitWidth="32" desc="UART receiver control register" hidden="false">
      <field name="STOP_BITS" from="2" to="0" access="RW" resetVal="" desc="Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods." hidden="false" />
      <field name="PARITY" from="4" to="4" access="RW" resetVal="" desc="Parity bit. When '0', the receiver expects an even parity. When '1', the receiver expects an odd parity." hidden="false" />
      <field name="PARITY_ENABLED" from="5" to="5" access="RW" resetVal="" desc="Parity checking enabled ('1') or not ('0'). Only applicable in standard UART submode. In SmartCard submode, parity checking is always enabled through hardware. In IrDA submode, parity checking is always disabled through hardware." hidden="false" />
      <field name="POLARITY" from="6" to="6" access="RW" resetVal="" desc="Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality." hidden="false" />
      <field name="DROP_ON_PARITY_ERR" from="8" to="8" access="RW" resetVal="" desc="Behaviour when a parity check fails. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost." hidden="false" />
      <field name="DROP_ON_FRAME_ERR" from="9" to="9" access="RW" resetVal="" desc="Behaviour when an error is detected in a start or stop period. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost." hidden="false" />
      <field name="MP_MODE" from="10" to="10" access="RW" resetVal="" desc="Multi-processor mode. When '1', multi-processor mode is enabled. In this mode, RX_CTRL.DATA_WIDTH should indicate a 9-bit data frame." hidden="false" />
      <field name="LIN_MODE" from="12" to="12" access="RW" resetVal="" desc="Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data" hidden="false" />
      <field name="SKIP_START" from="13" to="13" access="RW" resetVal="" desc="Only applicable in standard UART submode. When '1', the receiver skips start bit detection for the first received data frame. Instead, it synchronizes on the first received data frame bit, which should be a '1'." hidden="false" />
      <field name="BREAK_WIDTH" from="19" to="16" access="RW" resetVal="" desc="Break width. BREAK_WIDTH + 1 is the minimum width in bit periods of a break." hidden="false" />
    </register>
    <register name="_UART_FLOW_CTRL" address="0x40080050" bitWidth="32" desc="UART flow control register" hidden="false">
      <field name="TRIGGER_LEVEL" from="3" to="0" access="RW" resetVal="" desc="Trigger level. When the receiver FIFO has less entries than the amount of this field, a RTS signal is activated. Setting this field to 0 disables RTS generation." hidden="false" />
      <field name="RTS_POLARITY" from="16" to="16" access="RW" resetVal="" desc="Polarity of the RTS output signal" hidden="false" />
      <field name="CTS_POLARITY" from="24" to="24" access="RW" resetVal="" desc="Polarity of the CTS input signal" hidden="false" />
      <field name="CTS_ENABLED" from="25" to="25" access="RW" resetVal="" desc="Enable use of CTS input signal by the UART transmitter" hidden="false" />
    </register>
    <register name="_I2C_CTRL" address="0x40080060" bitWidth="32" desc="I2C control register" hidden="false">
      <field name="HIGH_PHASE_OVS" from="3" to="0" access="RW" resetVal="" desc="Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 peripheral clock periods constitute the high phase of a bit period." hidden="false" />
      <field name="LOW_PHASE_OVS" from="7" to="4" access="RW" resetVal="" desc="Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 peripheral clock periods constitute the low phase of a bit period" hidden="false" />
      <field name="M_READY_DATA_ACK" from="8" to="8" access="RW" resetVal="" desc="When '1', a received data element by the master is immediately ACK'd when the receiver FIFO is not full." hidden="false" />
      <field name="M_NOT_READY_DATA_NACK" from="9" to="9" access="RW" resetVal="" desc="When '1', a received data element byte the master is immediately NACK'd when the receiver FIFO is full. When '0', clock stretching is used instead (till the receiver FIFO is no longer full)." hidden="false" />
      <field name="S_GENERAL_IGNORE" from="11" to="11" access="RW" resetVal="" desc="When '1', a received general call slave address is immediately NACK'd (no ACK or clock stretching) and treated as a non matching slave address." hidden="false" />
      <field name="S_READY_ADDR_ACK" from="12" to="12" access="RW" resetVal="" desc="When '1', a received (matching) slave address is immediately ACK'd when the receiver FIFO is not full" hidden="false" />
      <field name="S_READY_DATA_ACK" from="13" to="13" access="RW" resetVal="" desc="When '1', a received data element by the slave is immediately ACK'd when the receiver FIFO is not full" hidden="false" />
      <field name="S_NOT_READY_ADDR_NACK" from="14" to="14" access="RW" resetVal="" desc="When '1', a received address by the slave is immediately ACK'd when the receiver FIFO is not full" hidden="false" />
      <field name="S_NOT_READY_DATA_NACK" from="15" to="15" access="RW" resetVal="" desc=" When '1' a received data element byte the slave is immediately NACK'd when the receiver FIFO is full. When '1' clock stretching is performed (till the receiver FIFO is no longer full)." hidden="false" />
      <field name="LOOPBACK" from="16" to="16" access="RW" resetVal="" desc="Local loopback control" hidden="false" />
      <field name="SLAVE_MODE" from="30" to="30" access="RW" resetVal="" desc="Slave mode enabled ('1') or not ('0')." hidden="false" />
      <field name="MASTER_MODE" from="31" to="31" access="RW" resetVal="" desc="Master mode enabled ('1') or not ('0'). Note that both master and slave modes can be enabled at the same time. This allows the IP to address itself." hidden="false" />
    </register>
    <register name="_I2C_STATUS" address="0x40080064" bitWidth="32" desc="I2C status register" hidden="false">
      <field name="BUS_BUSY" from="0" to="0" access="R" resetVal="" desc="I2C bus is busy. The bus is considered busy ('1')." hidden="false" />
      <field name="S_READ" from="4" to="4" access="R" resetVal="" desc="I2C slave read transfer ('1') or I2C slave write transfer ('0'). When the I2C slave is inactive/idle or receiving START, REPEATED START, STOP or an address, this field is '0'." hidden="false" />
      <field name="M_READ" from="5" to="5" access="R" resetVal="" desc="I2C master read transfer ('1') or I2C master write transfer ('0'). When the I2C master is inactive/idle or transmitting START, REPEATED START, STOP or an address, this field is '0''." hidden="false" />
    </register>
    <register name="_I2C_M_CMD" address="0x40080068" bitWidth="32" desc="I2C master command register" hidden="false">
      <field name="M_START" from="0" to="0" access="RW" resetVal="" desc="When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. When this action is performed, the hardware sets this field to '0'." hidden="false" />
      <field name="M_IDLE_START" from="1" to="1" access="RW" resetVal="" desc="When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). When this action is performed, the hardware sets this field to '0'." hidden="false" />
      <field name="M_ACK" from="2" to="2" access="RW" resetVal="" desc="When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'." hidden="false" />
      <field name="M_NACK" from="3" to="3" access="RW" resetVal="" desc="When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'." hidden="false" />
      <field name="M_STOP" from="4" to="4" access="RW" resetVal="" desc="When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. This command has a higher priority than I2C_M_CMD.M_START: in situations where both a STOP and a REPEATED START could be transmitted, M_STOP takes precedence over M_START." hidden="false" />
    </register>
    <register name="_I2C_S_CMD" address="0x4008006C" bitWidth="32" desc="I2C slave command register" hidden="false">
      <field name="S_ACK" from="0" to="0" access="RW" resetVal="" desc="When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'." hidden="false" />
      <field name="S_NACK" from="1" to="1" access="RW" resetVal="" desc="When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'" hidden="false" />
    </register>
    <register name="_I2C_CFG" address="0x40080070" bitWidth="32" desc="I2C fitler trimm register" hidden="false">
      <field name="SDA_IN_FILT_TRIM" from="1" to="0" access="RW" resetVal="" desc="" hidden="false" />
      <field name="SDA_IN_FILT_SEL" from="4" to="4" access="RW" resetVal="" desc="" hidden="false" />
      <field name="SCL_IN_FILT_TRIM" from="9" to="8" access="RW" resetVal="" desc="" hidden="false" />
      <field name="SCL_IN_FILT_SEL" from="12" to="12" access="RW" resetVal="" desc="" hidden="false" />
      <field name="SDA_OUT_FILT0_TRIM" from="17" to="16" access="RW" resetVal="" desc="" hidden="false" />
      <field name="SDA_OUT_FILT1_TRIM" from="19" to="18" access="RW" resetVal="" desc="" hidden="false" />
      <field name="SDA_OUT_FILT2_TRIM" from="21" to="20" access="RW" resetVal="" desc="" hidden="false" />
      <field name="SDA_OUT_FILT_SEL" from="29" to="28" access="RW" resetVal="" desc="" hidden="false" />
    </register>
    <register name="_TX_CTRL" address="0x40080200" bitWidth="32" desc="Transmitter control register" hidden="false">
      <field name="DATA_WIDTH" from="3" to="0" access="RW" resetVal="" desc="Data frame width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame." hidden="false" />
      <field name="MSB_FIRST" from="8" to="8" access="RW" resetVal="" desc="Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'." hidden="false" />
    </register>
    <register name="_TX_FIFO_CTRL" address="0x40080204" bitWidth="32" desc="Transmitter FIFO control register" hidden="false">
      <field name="TRIGGER_LEVEL" from="3" to="0" access="RW" resetVal="" desc="Trigger level. When the transmitter FIFO has less entries than the amount of this field, a transmitter trigger event is generated." hidden="false" />
      <field name="CLEAR" from="16" to="16" access="RW" resetVal="" desc="When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period." hidden="false" />
      <field name="FREEZE" from="17" to="17" access="RW" resetVal="" desc="When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer." hidden="false" />
    </register>
    <register name="_TX_FIFO_STATUS" address="0x40080208" bitWidth="32" desc="Transmitter FIFO status register" hidden="false">
      <field name="USED" from="4" to="0" access="R" resetVal="" desc="Amount of entries in the transmitter FIFO. The value of this field ranges from 0 to 8." hidden="false" />
      <field name="SR_VALID" from="15" to="15" access="R" resetVal="" desc="Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0')" hidden="false" />
      <field name="RD_PTR" from="20" to="16" access="R" resetVal="" desc="FIFO read pointer: FIFO location from which a data frame is read by the hardware." hidden="false" />
      <field name="WR_PTR" from="28" to="24" access="R" resetVal="" desc="FIFO write pointer: FIFO location at which a new data frame is written." hidden="false" />
    </register>
    <register name="_TX_FIFO_WR" address="0x40080240" bitWidth="32" desc="Transmitter FIFO write register" hidden="false">
      <field name="DATA" from="15" to="0" access="W" resetVal="" desc="Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation." hidden="false" />
    </register>
    <register name="_RX_CTRL" address="0x40080300" bitWidth="32" desc="Receiver control register" hidden="false">
      <field name="DATA_WIDTH" from="3" to="0" access="RW" resetVal="" desc="Data frame width. DATA_WIDTH + 1 is the expected amount of bits in received data frame." hidden="false" />
      <field name="MSB_FIRST" from="8" to="8" access="RW" resetVal="" desc="Least significant bit first ('0') or most significant bit first ('1')." hidden="false" />
      <field name="MEDIAN" from="9" to="9" access="RW" resetVal="" desc="Median filter. When '1', a digital 3 taps median filter is performed on input interface lines." hidden="false" />
    </register>
    <register name="_RX_FIFO_CTRL" address="0x40080304" bitWidth="32" desc="Receiver FIFO control register" hidden="false">
      <field name="TRIGGER_LEVEL" from="3" to="0" access="RW" resetVal="" desc="Trigger level. When the receiver FIFO has more entries than the amount of this field, a receiver trigger event is generated." hidden="false" />
      <field name="CLEAR" from="16" to="16" access="RW" resetVal="" desc="When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period." hidden="false" />
      <field name="FREEZE" from="17" to="17" access="RW" resetVal="" desc="When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer." hidden="false" />
    </register>
    <register name="_RX_FIFO_STATUS" address="0x40080308" bitWidth="32" desc="Receiver FIFO status registerS" hidden="false">
      <field name="USED" from="4" to="0" access="R" resetVal="" desc="Amount of entries in the receiver FIFO. The value of this field ranges from 0 to 8." hidden="false" />
      <field name="SR_VALID" from="15" to="15" access="R" resetVal="" desc="Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0')." hidden="false" />
      <field name="RD_PTR" from="20" to="16" access="R" resetVal="" desc="FIFO read pointer: FIFO location from which a data frame is read." hidden="false" />
      <field name="WR_PTR" from="28" to="24" access="R" resetVal="" desc="FIFO write pointer: FIFO location at which a new data frame is written by the hardware." hidden="false" />
    </register>
    <register name="_RX_MATCH" address="0x40080310" bitWidth="32" desc="Slave address and mask register" hidden="false">
      <field name="ADDR" from="7" to="0" access="RW" resetVal="" desc="Slave device address. For UART multi-processor mode all eight bits a reused. For I2C, bit 0 of the register is not used." hidden="false" />
      <field name="MASK" from="23" to="16" access="RW" resetVal="" desc="Slave device address mask. This field is a 8 bit mask that specifies which of the ADDR field bits in the SCB_RX_MATCH_ADDR register take part in the matching of the slave address." hidden="false" />
    </register>
    <register name="_RX_FIFO_RD" address="0x40080340" bitWidth="32" desc="Receiver FIFO read register" hidden="false">
      <field name="DATA" from="15" to="0" access="R" resetVal="" desc="Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO." hidden="false" />
    </register>
    <register name="_INTR_CAUSE" address="0x40080E00" bitWidth="32" desc="Interrupt cause register" hidden="false">
      <field name="MASTER" from="0" to="0" access="R" resetVal="" desc="Master interrupt active." hidden="false" />
      <field name="SLAVE" from="1" to="1" access="R" resetVal="" desc="Slave interrupt active." hidden="false" />
      <field name="TX" from="2" to="2" access="R" resetVal="" desc="Transmitter interrupt active." hidden="false" />
      <field name="RX" from="3" to="3" access="R" resetVal="" desc="Receiver interrupt active." hidden="false" />
      <field name="I2C_EC" from="4" to="4" access="R" resetVal="" desc="Externally clock I2C interrupt active." hidden="false" />
      <field name="SPI_EC" from="5" to="5" access="R" resetVal="" desc="Externally clocked SPI interrupt active." hidden="false" />
    </register>
    <register name="_INTR_I2C_EC" address="0x40080E80" bitWidth="32" desc="Externally clocked I2C interrupt request register" hidden="false">
      <field name="WAKE_UP" from="0" to="0" access="RW" resetVal="" desc="Wake up request. Active on incoming slave request (with address match). Only used when EC_AM is '1'." hidden="false" />
    </register>
    <register name="_INTR_I2C_EC_MASK" address="0x40080E88" bitWidth="32" desc="Externally clocked I2C interrupt mask register" hidden="false">
      <field name="WAKE_UP" from="0" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_I2C_EC_MASKED" address="0x40080E8C" bitWidth="32" desc="Externally clocked SPI interrupt masked register" hidden="false">
      <field name="WAKE_UP" from="0" to="0" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
    </register>
    <register name="_INTR_INTR_SPI_EC" address="0x40080EC0" bitWidth="32" desc="Externally clocked SPI interrupt request register" hidden="false">
      <field name="WAKE_UP" from="0" to="0" access="RW" resetVal="" desc="Wake up request. Active on incoming slave request when externally clocked selection is '1'." hidden="false" />
    </register>
    <register name="_INTR_INTR_SPI_EC_MASK" address="0x40080EC8" bitWidth="32" desc="Externally clocked SPI interrupt mask register" hidden="false">
      <field name="WAKE_UP" from="0" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_INTR_SPI_EC_MASKED" address="0x40080ECC" bitWidth="32" desc="Externally clocked SPI interrupt masked register" hidden="false">
      <field name="WAKE_UP" from="0" to="0" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
    </register>
    <register name="_INTR_M" address="0x40080F00" bitWidth="32" desc="Master interrupt request register." hidden="false">
      <field name="I2C_LOST_ARB" from="0" to="0" access="RW" resetVal="" desc="I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data)." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data)." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="I2C master STOP. Set to '1', when the master has transmitted a STOP." hidden="false" />
      <field name="I2C_BUS_ERR" from="8" to="8" access="RW" resetVal="" desc="I2C master bus error (unexpected detection of START or STOP condition)." hidden="false" />
      <field name="SPI_DONE" from="9" to="9" access="RW" resetVal="" desc="SPI master transfer done event: all data frames in the transmit FIFO are sent and the transmit FIFO is empty." hidden="false" />
    </register>
    <register name="_INTR_M_SET" address="0x40080F04" bitWidth="32" desc="Master interrupt set request register" hidden="false">
      <field name="I2C_LOST_ARB" from="0" to="0" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_BUS_ERR" from="8" to="8" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="SPI_DONE" from="9" to="9" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_M_MASK" address="0x40080F08" bitWidth="32" desc="Master interrupt mask register" hidden="false">
      <field name="I2C_LOST_ARB" from="0" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_BUS_ERR" from="8" to="8" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="SPI_DONE" from="9" to="9" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_M_MASKED" address="0x40080F0C" bitWidth="32" desc="Master interrupt masked request register" hidden="false">
      <field name="I2C_LOST_ARB" from="0" to="0" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_BUS_ERR" from="8" to="8" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="SPI_DONE" from="9" to="9" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
    </register>
    <register name="_INTR_S" address="0x40080F40" bitWidth="32" desc="Slave interrupt request register" hidden="false">
      <field name="I2C_ARB_LOST" from="0" to="0" access="RW" resetVal="" desc="I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1')." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="I2C slave negative acknowledgement received. Set to '1', when the slave receives a NACK (typically after the slave transmitted TX data)." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="I2C slave acknowledgement received. Set to '1', when the slave receives a ACK (typically after the slave transmitted TX data)." hidden="false" />
      <field name="I2C_WRITE_STOP" from="3" to="3" access="RW" resetVal="" desc="I2C STOP event for I2C write transfer intended for this slave (address matching is performed).Set to '1', when STOP or REPEATED START event is detected." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="I2C STOP event for I2C (read or write) transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected" hidden="false" />
      <field name="I2C_START" from="5" to="5" access="RW" resetVal="" desc="I2C slave START received. Set to '1', when START or REPEATED START event is detected." hidden="false" />
      <field name="I2C_ADDR_MATCH" from="6" to="6" access="RW" resetVal="" desc="I2C slave matching address received. If CTRL.ADDR_ACCEPT, the received address (including the R/W bit) is available in the RX FIFO." hidden="false" />
      <field name="I2C_GENERAL" from="7" to="7" access="RW" resetVal="" desc="I2C slave general call address received.  If CTRL.ADDR_ACCEPT, the received address 0x00 (including the R/W bit) is available in the RX FIFO" hidden="false" />
      <field name="I2C_BUS_ERR" from="8" to="8" access="RW" resetVal="" desc="I2C slave bus error (unexpected detection of START or STOP condition)." hidden="false" />
      <field name="SPI_BUS_ERR" from="11" to="11" access="RW" resetVal="" desc="SPI slave deselected at an unexpected time in the SPI transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error." hidden="false" />
    </register>
    <register name="_INTR_S_SET" address="0x40080F44" bitWidth="32" desc="Slave interrupt set request register" hidden="false">
      <field name="I2C_ARB_LOST" from="0" to="0" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_WRITE_STOP" from="3" to="3" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_START" from="5" to="5" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_ADDR_MATCH" from="6" to="6" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_GENERAL" from="7" to="7" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_BUS_ERR" from="8" to="8" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="SPI_BUS_ERR" from="11" to="11" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_S_MASK" address="0x40080F48" bitWidth="32" desc="Slave interrupt mask register" hidden="false">
      <field name="I2C_ARB_LOST" from="0" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_WRITE_STOP" from="3" to="3" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_START" from="5" to="5" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_ADDR_MATCH" from="6" to="6" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_GENERAL" from="7" to="7" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_BUS_ERR" from="8" to="8" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="SPI_BUS_ERR" from="11" to="11" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_S_MASKED" address="0x40080F4C" bitWidth="32" desc="Slave interrupt masked register" hidden="false">
      <field name="I2C_ARB_LOST" from="0" to="0" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_WRITE_STOP" from="3" to="3" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_START" from="5" to="5" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_ADDR_MATCH" from="6" to="6" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_GENERAL" from="7" to="7" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="SPI_BUS_ERR" from="11" to="11" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
    </register>
    <register name="_INTR_TX" address="0x40080F80" bitWidth="32" desc="Transmitter interrupt request register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="Less entries in the TX FIFO than the value specified by TRIGGER_LEVEL in SCB_TX_FIFO_CTL." hidden="false" />
      <field name="NOT_FULL" from="1" to="1" access="RW" resetVal="" desc="TX FIFO is not full." hidden="false" />
      <field name="EMPTY" from="4" to="4" access="RW" resetVal="" desc="TX FIFO is empty; i.e. it has 0 entries." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Attempt to write to a full TX FIFO." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Attempt to read from an empty TX FIFO." hidden="false" />
      <field name="UART_NACK" from="8" to="8" access="RW" resetVal="" desc="UART transmitter received a negative acknowledgement in SmartCard mode. Set to '1', when event is detected." hidden="false" />
      <field name="UART_DONE" from="9" to="9" access="RW" resetVal="" desc="UART transmitter done event. This happens when the IP is done transferring all data in the TX FIFO; i.e. EMPTY is '1'. Set to '1', when event is detected." hidden="false" />
      <field name="UART_ARB_LOST" from="10" to="10" access="RW" resetVal="" desc="UART lost arbitration: the value driven on the TX line is not the same as the value observed on the RX line. " hidden="false" />
    </register>
    <register name="_INTR_TX_SET" address="0x40080F84" bitWidth="32" desc="Transmitter interrupt set request register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="NOT_FULL" from="1" to="1" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="EMPTY" from="4" to="4" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="UART_NACK" from="8" to="8" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="UART_DONE" from="9" to="9" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="UART_ARB_LOST" from="10" to="10" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_TX_MASK" address="0x40080F88" bitWidth="32" desc="Transmitter interrupt mask request register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="NOT_FULL" from="1" to="1" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="EMPTY" from="4" to="4" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="UART_NACK" from="8" to="8" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="UART_DONE" from="9" to="9" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="UART_ARB_LOST" from="10" to="10" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_TX_MASKED" address="0x40080F8C" bitWidth="32" desc="Transmitter interrupt masked request register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="NOT_FULL" from="1" to="1" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="EMPTY" from="4" to="4" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="UART_NACK" from="8" to="8" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="UART_DONE" from="9" to="9" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="UART_ARB_LOST" from="10" to="10" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
    </register>
    <register name="_INTR_RX" address="0x40080FC0" bitWidth="32" desc="Receiver interrupt request register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="More entries in the RX FIFO than the value specified by TRIGGER_LEVEL in SCB_RX_FIFO_CTL." hidden="false" />
      <field name="NOT_EMPTY" from="2" to="2" access="RW" resetVal="" desc="RX FIFO is not empty." hidden="false" />
      <field name="FULL" from="3" to="3" access="RW" resetVal="" desc="RX FIFO is full. Note that received data frames are lost when the RX FIFO is full." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Attempt to write to a full RX FIFO. Note: in I2C mode, the OVERFLOW is set when a data frame is received and the RX FIFO is full, independent of whether it is ACK'd or NACK'd." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Attempt to read from an empty RX FIFO." hidden="false" />
      <field name="FRAME_ERR" from="8" to="8" access="RW" resetVal="" desc="Frame error in received data frame. Set to '1', when event is detected." hidden="false" />
      <field name="PARITY_ERR" from="9" to="9" access="RW" resetVal="" desc="Parity error in received data frame. Set to '1', when event is detected." hidden="false" />
      <field name="BAUD_DETECT" from="10" to="10" access="RW" resetVal="" desc="LIN baud rate detection is completed." hidden="false" />
      <field name="BREAK_DETECT" from="11" to="11" access="RW" resetVal="" desc="Break detection is successful: the line is '0' for UART_RX_CTRL.BREAK_WIDTH + 1 bit period." hidden="false" />
    </register>
    <register name="_INTR_RX_SET" address="0x40080FC4" bitWidth="32" desc="Receiver interrupt set request register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="NOT_EMPTY" from="2" to="2" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="FULL" from="3" to="3" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="FRAME_ERR" from="8" to="8" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="PARITY_ERR" from="9" to="9" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="BAUD_DETECT" from="10" to="10" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="BREAK_DETECT" from="11" to="11" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_RX_MASK" address="0x40080FC8" bitWidth="32" desc="Receiver interrupt mask register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="NOT_EMPTY" from="2" to="2" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="FULL" from="3" to="3" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="FRAME_ERR" from="8" to="8" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="PARITY_ERR" from="9" to="9" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="BAUD_DETECT" from="10" to="10" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="BREAK_DETECT" from="11" to="11" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_RX_MASKED" address="0x40080FCC" bitWidth="32" desc="Receiver interrupt masked register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="NOT_EMPTY" from="2" to="2" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="FULL" from="3" to="3" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="FRAME_ERR" from="8" to="8" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits" hidden="false" />
      <field name="PARITY_ERR" from="9" to="9" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits" hidden="false" />
      <field name="BAUD_DETECT" from="10" to="10" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits" hidden="false" />
      <field name="BREAK_DETECT" from="11" to="11" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits" hidden="false" />
    </register>
  </block>
  <block name="Q_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="PWR_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="LED1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="D_7" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="R_11" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="D_5" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="R_9" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="DMAC" BASE="0x0" SIZE="0x0" desc="DMAC Registers" visible="true" hidden="false">
    <register name="DMAC_CH_CTL17" address="0x40000000" bitWidth="32" desc="DMA channel 17 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL8" address="0x40000000" bitWidth="32" desc="DMA channel 8 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL9" address="0x40000000" bitWidth="32" desc="DMA channel 9 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL20" address="0x40000000" bitWidth="32" desc="DMA channel 20 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL19" address="0x40000000" bitWidth="32" desc="DMA channel 19 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL18" address="0x40000000" bitWidth="32" desc="DMA channel 18 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL13" address="0x40000000" bitWidth="32" desc="DMA channel 13 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL14" address="0x40000000" bitWidth="32" desc="DMA channel 14 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL15" address="0x40000000" bitWidth="32" desc="DMA channel 15 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL10" address="0x40000000" bitWidth="32" desc="DMA channel 10 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL11" address="0x40000000" bitWidth="32" desc="DMA channel 11 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL12" address="0x40000000" bitWidth="32" desc="DMA channel 12 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL29" address="0x40000000" bitWidth="32" desc="DMA channel 29 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL28" address="0x40000000" bitWidth="32" desc="DMA channel 28 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL27" address="0x40000000" bitWidth="32" desc="DMA channel 27 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL16" address="0x40000000" bitWidth="32" desc="DMA channel 16 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL31" address="0x40000000" bitWidth="31" desc="DMA channel 31 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL30" address="0x40000000" bitWidth="32" desc="DMA channel 30 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL26" address="0x40000000" bitWidth="32" desc="DMA channel 26 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL23" address="0x40000000" bitWidth="32" desc="DMA channel 23 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL22" address="0x40000000" bitWidth="32" desc="DMA channel 22 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL21" address="0x40000000" bitWidth="32" desc="DMA channel 21 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL25" address="0x40000000" bitWidth="32" desc="DMA channel 25 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL24" address="0x40000000" bitWidth="32" desc="DMA channel 24 control register" hidden="true">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CTL" address="0x40101000" bitWidth="32" desc="DMA controller control register" hidden="false">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Global DMAC enable" hidden="false">
        <value name="Disabled" value="0" desc="DMA controller is disabled." />
        <value name="Enabled" value="1" desc="DMA controller is enabled." />
      </field>
    </register>
    <register name="DMAC_STATUS" address="0x40101010" bitWidth="32" desc="DMA controller status register" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="R" resetVal="" desc="Specifies the index of the currently active data transfer. This value increases from '0' to the DATA_NR field specified of the currently active descriptor control word." hidden="false" />
      <field name="CH_ADDR" from="20" to="16" access="R" resetVal="" desc="Specifies the channel number of the currently active channel. For example, if channel 7 is active, DMAC_STATUS.ACTIVE is '1' and STATUS.CH_ADDR is '7'." hidden="false" />
      <field name="STATE" from="26" to="24" access="R" resetVal="" desc="State of the data transfer engine." hidden="false">
        <value name="IDLE" value="000" desc="Idle state when the DMA is not active." />
        <value name="LOAD_DESCR" value="001" desc="The DMA is loading the descriptor to the DMA transfer engine." />
        <value name="LOAD_SRC" value="010" desc="The DMA is getting the value from the source location." />
        <value name="STORE_DST" value="011" desc="The DMA is storing the value at the destination location." />
        <value name="STORE_DESCR" value="100" desc="The DMA is updating the descriptors after completion of transfer." />
        <value name="WAIT_TRIG_DEACT" value="101" desc="The DMA is waiting for the level sensitive trigger to deactivate." />
        <value name="STORE_ERROR" value="110" desc="There was an error during the transaction and the DMA is writing the error code to the channel status register." />
      </field>
      <field name="PRIO" from="29" to="28" access="R" resetVal="" desc="Specifies the priority of the currently active channel." hidden="false" />
      <field name="PING_PONG" from="31" to="31" access="R" resetVal="" desc="Specifies whether the PING descriptor ('0') or PONG descriptor ('1') of the channel is currently in use." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="ACTIVE" from="31" to="31" access="R" resetVal="" desc="Specifies if there is a currently active (pending) channel in the data transfer engine." hidden="false">
        <value name="IDLE" value="0" desc="No currently active channel." />
        <value name="ACTIVE" value="1" desc="Currently active channel." />
      </field>
    </register>
    <register name="DMAC_STATUS_SRC_ADDR" address="0x40101014" bitWidth="32" desc="Source address currently being used by the DMA controller" hidden="false">
      <field name="ADDR" from="31" to="0" access="R" resetVal="" desc="The source address currently being used by the DMA transfer engine. This field is provided for debug purposes. Note while reading the DMAC_STATUS, DMAC_STATUS_SRC_ADDR and DMAC_STATUS_DST_ADDR registers, the transfer engine may have advanced after one or more of these reads. Meaning the register values may not be related to each other." hidden="false" />
    </register>
    <register name="DMAC_STATUS_DST_ADDR" address="0x40101018" bitWidth="32" desc="Destination address currently being used by the DMA controller" hidden="false">
      <field name="ADDR" from="31" to="0" access="R" resetVal="" desc="The destination address currently being used by the DMA transfer engine. This field is provided for debug purposes. Note while reading the DMAC_STATUS, DMAC_STATUS_SRC_ADDR and DMAC_STATUS_DST_ADDR registers, the transfer engine may have advanced after one or more of these reads. Meaning the register values may not be related to each other." hidden="false" />
    </register>
    <register name="DMAC_STATUS_CH_ACT" address="0x4010101C" bitWidth="32" desc="Channel activation status" hidden="false">
      <field name="CH" from="31" to="0" access="R" resetVal="" desc="Channel activation status. Bit i is associated to channel i. Software reads this field to get information on all actively pending channels (either in pending or in the data transfer engine)." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL0" address="0x40101080" bitWidth="32" desc="DMA channel 0 control register" hidden="false">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL1" address="0x40101084" bitWidth="32" desc="DMA channel 1 control register" hidden="false">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL2" address="0x40101088" bitWidth="32" desc="DMA channel 2 control register" hidden="false">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL3" address="0x4010108C" bitWidth="32" desc="DMA channel 3 control register" hidden="false">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL4" address="0x40101090" bitWidth="32" desc="DMA channel 4 control register" hidden="false">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL5" address="0x40101094" bitWidth="32" desc="DMA channel 5 control register" hidden="false">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL6" address="0x40101098" bitWidth="32" desc="DMA channel 6 control register" hidden="false">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_CH_CTL7" address="0x4010109C" bitWidth="32" desc="DMA channel 7 control register" hidden="false">
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Channel enable control." hidden="false">
        <value name="Disabled" value="0" desc="Channel is currently disabled." />
        <value name="Enabled" value="1" desc="Channel is currently enabled." />
      </field>
      <field name="PING_PONG" from="30" to="30" access="RW" resetVal="" desc="Identifies the descriptor structure that is currently in use by the DMA controller." hidden="false">
        <value name="DESCR0" value="0" desc="Descriptor 0 (PING) is currently in use." />
        <value name="DESCR1" value="1" desc="Descriptor 1 (PONG) is currently in use." />
      </field>
      <field name="PRIO" from="29" to="28" access="RW" resetVal="" desc="Channel priority. Priority can be 0,1,2 or 3. 0 is the highest." hidden="false" />
    </register>
    <register name="DMAC_INTR" address="0x401017F0" bitWidth="32" desc="Interrupt register" hidden="false">
      <field name="CH" from="31" to="0" access="RW" resetVal="" desc="Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit." hidden="false" />
    </register>
    <register name="DMAC_INTR_SET" address="0x401017F4" bitWidth="32" desc="Interrupt set register" hidden="false">
      <field name="CH" from="31" to="0" access="RW" resetVal="" desc="Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect)." hidden="false" />
    </register>
    <register name="DMAC_INTR_MASK" address="0x401017F8" bitWidth="32" desc="Interrupt mask register" hidden="false">
      <field name="CH" from="31" to="0" access="RW" resetVal="" desc="Mask for corresponding field in INTR register." hidden="false" />
    </register>
    <register name="DMAC_INTR_MASKED" address="0x401017FC" bitWidth="32" desc="Interrupt masked register" hidden="false">
      <field name="CH" from="31" to="0" access="R" resetVal="" desc="Bitwise AND between the interrupt reguest (INTR) and mask (INTR_MASK) registers." hidden="false" />
    </register>
    <register name="DMAC_DESCR0_PING_SRC" address="0x40101800" bitWidth="32" desc="Descriptor 0 source address location for channel 0" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR0_PING_DST" address="0x40101804" bitWidth="32" desc="Descriptor 0 destination address location for channel 0" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR0_PING_CTL" address="0x40101808" bitWidth="32" desc="Descriptor 0 control register for channel 0" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR0_PING_STATUS" address="0x4010180C" bitWidth="32" desc="Descriptor 0 status register for channel 0" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR0_PONG_SRC" address="0x40101810" bitWidth="32" desc="Descriptor 1 source address location for channel 0" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR0_PONG_DST" address="0x40101814" bitWidth="32" desc="Descriptor 1 destination address location for channel 0" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR0_PONG_CTL" address="0x40101818" bitWidth="32" desc="Descriptor 1 control register for channel 0" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR0_PONG_STATUS" address="0x4010181C" bitWidth="32" desc="Descriptor 1 status register for channel 0" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR1_PING_SRC" address="0x40101820" bitWidth="32" desc="Descriptor 0 source address location for channel 1" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR1_PING_DST" address="0x40101824" bitWidth="32" desc="Descriptor 0 destination address location for channel 1" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR1_PING_CTL" address="0x40101828" bitWidth="32" desc="Descriptor 0 control register for channel 1" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR1_PING_STATUS" address="0x4010182C" bitWidth="32" desc="Descriptor 0 status register for channel 1" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR1_PONG_SRC" address="0x40101830" bitWidth="32" desc="Descriptor 1 source address location for channel 1" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR1_PONG_DST" address="0x40101834" bitWidth="32" desc="Descriptor 1 destination address location for channel 1" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR1_PONG_CTL" address="0x40101838" bitWidth="32" desc="Descriptor 1 control register for channel 1" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR1_PONG_STATUS" address="0x4010183C" bitWidth="32" desc="Descriptor 1 status register for channel 1" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR2_PING_SRC" address="0x40101840" bitWidth="32" desc="Descriptor 0 source address location for channel 2" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR2_PING_DST" address="0x40101844" bitWidth="32" desc="Descriptor 0 destination address location for channel 2" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR2_PING_CTL" address="0x40101848" bitWidth="32" desc="Descriptor 0 control register for channel 2" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR2_PING_STATUS" address="0x4010184C" bitWidth="32" desc="Descriptor 0 status register for channel 2" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR2_PONG_SRC" address="0x40101850" bitWidth="32" desc="Descriptor 1 source address location for channel 2" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR2_PONG_DST" address="0x40101854" bitWidth="32" desc="Descriptor 1 destination address location for channel 2" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR2_PONG_CTL" address="0x40101858" bitWidth="32" desc="Descriptor 1 control register for channel 2" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR2_PONG_STATUS" address="0x4010185C" bitWidth="32" desc="Descriptor 1 status register for channel 2" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR3_PING_SRC" address="0x40101860" bitWidth="32" desc="Descriptor 0 source address location for channel 3" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR3_PING_DST" address="0x40101864" bitWidth="32" desc="Descriptor 0 destination address location for channel 3" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR3_PING_CTL" address="0x40101868" bitWidth="32" desc="Descriptor 0 control register for channel 3" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR3_PING_STATUS" address="0x4010186C" bitWidth="32" desc="Descriptor 0 status register for channel 3" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR3_PONG_SRC" address="0x40101870" bitWidth="32" desc="Descriptor 1 source address location for channel 3" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR3_PONG_DST" address="0x40101874" bitWidth="32" desc="Descriptor 1 destination address location for channel 3" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR3_PONG_CTL" address="0x40101878" bitWidth="32" desc="Descriptor 1 control register for channel 3" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR3_PONG_STATUS" address="0x4010187C" bitWidth="32" desc="Descriptor 1 status register for channel 3" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR4_PING_SRC" address="0x40101880" bitWidth="32" desc="Descriptor 0 source address location for channel 4" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR4_PING_DST" address="0x40101884" bitWidth="32" desc="Descriptor 0 destination address location for channel 4" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR4_PING_CTL" address="0x40101888" bitWidth="32" desc="Descriptor 0 control register for channel 4" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR4_PING_STATUS" address="0x4010188C" bitWidth="32" desc="Descriptor 0 status register for channel 4" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR4_PONG_SRC" address="0x40101890" bitWidth="32" desc="Descriptor 1 source address location for channel 4" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR4_PONG_DST" address="0x40101894" bitWidth="32" desc="Descriptor 1 destination address location for channel 4" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR4_PONG_CTL" address="0x40101898" bitWidth="32" desc="Descriptor 1 control register for channel 4" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR4_PONG_STATUS" address="0x4010189C" bitWidth="32" desc="Descriptor 1 status register for channel 4" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR5_PING_SRC" address="0x401018A0" bitWidth="32" desc="Descriptor 0 source address location for channel 5" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR5_PING_DST" address="0x401018A4" bitWidth="32" desc="Descriptor 0 destination address location for channel 5" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR5_PING_CTL" address="0x401018A8" bitWidth="32" desc="Descriptor 0 control register for channel 5" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR5_PING_STATUS" address="0x401018AC" bitWidth="32" desc="Descriptor 0 status register for channel 5" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR5_PONG_SRC" address="0x401018B0" bitWidth="32" desc="Descriptor 1 source address location for channel 5" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR5_PONG_DST" address="0x401018B4" bitWidth="32" desc="Descriptor 1 destination address location for channel 5" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR5_PONG_CTL" address="0x401018B8" bitWidth="32" desc="Descriptor 1 control register for channel 5" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR5_PONG_STATUS" address="0x401018BC" bitWidth="32" desc="Descriptor 1 status register for channel 5" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR6_PING_SRC" address="0x401018C0" bitWidth="32" desc="Descriptor 0 source address location for channel 6" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR6_PING_DST" address="0x401018C4" bitWidth="32" desc="Descriptor 0 destination address location for channel 6" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR6_PING_CTL" address="0x401018C8" bitWidth="32" desc="Descriptor 0 control register for channel 6" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR6_PING_STATUS" address="0x401018CC" bitWidth="32" desc="Descriptor 0 status register for channel 6" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR6_PONG_SRC" address="0x401018D0" bitWidth="32" desc="Descriptor 1 source address location for channel 6" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR6_PONG_DST" address="0x401018D4" bitWidth="32" desc="Descriptor 1 destination address location for channel 6" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR6_PONG_CTL" address="0x401018D8" bitWidth="32" desc="Descriptor 1 control register for channel 6" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR6_PONG_STATUS" address="0x401018DC" bitWidth="32" desc="Descriptor 1 status register for channel 6" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR7_PING_SRC" address="0x401018E0" bitWidth="32" desc="Descriptor 0 source address location for channel 7" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR7_PING_DST" address="0x401018E4" bitWidth="32" desc="Descriptor 0 destination address location for channel 7" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR7_PING_CTL" address="0x401018E8" bitWidth="32" desc="Descriptor 0 control register for channel 7" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR7_PING_STATUS" address="0x401018EC" bitWidth="32" desc="Descriptor 0 status register for channel 7" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
    <register name="DMAC_DESCR7_PONG_SRC" address="0x401018F0" bitWidth="32" desc="Descriptor 1 source address location for channel 7" hidden="false">
      <field name="SRC" from="31" to="0" access="RW" resetVal="" desc="Source address." hidden="false" />
    </register>
    <register name="DMAC_DESCR7_PONG_DST" address="0x401018F4" bitWidth="32" desc="Descriptor 1 destination address location for channel 7" hidden="false">
      <field name="DST" from="31" to="0" access="RW" resetVal="" desc="Destination address." hidden="false" />
    </register>
    <register name="DMAC_DESCR7_PONG_CTL" address="0x401018F8" bitWidth="32" desc="Descriptor 1 control register for channel 7" hidden="false">
      <field name="DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements." hidden="false" />
      <field name="DATA_SIZE" from="17" to="16" access="RW" resetVal="" desc="Specifies the data element size." hidden="false">
        <value name="BYTE" value="00" desc="1 byte." />
        <value name="HALFWORD" value="01" desc="Halfword (2 bytes)." />
        <value name="WORD" value="10" desc="Word (4 bytes)." />
      </field>
      <field name="DST_TRANSFER_SIZE" from="20" to="20" access="RW" resetVal="" desc="Specifies the bus transfer size to the destination location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="DST_ADDR_INCR" from="21" to="21" access="RW" resetVal="" desc="Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_DST_ADDR" value="1" desc="Increment the destination address." />
      </field>
      <field name="SRC_TRANSFER_SIZE" from="22" to="22" access="RW" resetVal="" desc="Specifies the bus transfer size to the source location." hidden="false">
        <value name="DATA_SIZE" value="0" desc="As specified by DATA_SIZE field." />
        <value name="WORD" value="1" desc="Word (4 bytes)." />
      </field>
      <field name="SRC_ADDR_INCR" from="23" to="23" access="RW" resetVal="" desc="Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element." hidden="false">
        <value name="INC_NONE" value="0" desc="No address increment." />
        <value name="INC_SRC_ADDR" value="1" desc="Increment the source address." />
      </field>
      <field name="WAIT_FOR_DEACT" from="25" to="24" access="RW" resetVal="" desc="Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance." hidden="false">
        <value name="PULSE" value="00" desc="Do not wait for de-activation (for pulse sensitive triggers)." />
        <value name="LEVEL_FOUR" value="01" desc="Wait for up to 4 cycles." />
        <value name="LEVEL_EIGHT" value="10" desc="Wait for up to 8 cycles." />
        <value name="LEVEL_UNKNOWN" value="11" desc="Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent." />
      </field>
      <field name="INV_DESCR" from="26" to="26" access="RW" resetVal="" desc="If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure." hidden="false" />
      <field name="SET_CAUSE" from="27" to="27" access="RW" resetVal="" desc="If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure." hidden="false" />
      <field name="PREEMPTABLE" from="28" to="28" access="RW" resetVal="" desc="If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled." hidden="false" />
      <field name="FLIPPING" from="29" to="29" access="RW" resetVal="" desc="If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures." hidden="false" />
      <field name="OPCODE" from="31" to="30" access="RW" resetVal="" desc="Specifies how the DMA reacts to a trigger event." hidden="false">
        <value name="SINGLE_DATA_ELEMENT" value="00" desc="A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1)." />
        <value name="ENTIRE_DESCRIPTOR" value="01" desc="A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed." />
        <value name="ENTIRE_DESCRIPTOR_CHAIN" value="10" desc="A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer)." />
      </field>
    </register>
    <register name="DMAC_DESCR7_PONG_STATUS" address="0x401018FC" bitWidth="32" desc="Descriptor 1 status register for channel 7" hidden="false">
      <field name="VALID" from="31" to="31" access="RW" resetVal="" desc="Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized." hidden="false">
        <value name="INVALID" value="0" desc="Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'." />
        <value name="VALID" value="1" desc="Valid." />
      </field>
      <field name="RESONSE" from="18" to="16" access="RW" resetVal="" desc="Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior)." hidden="false">
        <value name="NO_ERROR" value="000" desc="No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization." />
        <value name="DONE" value="001" desc="Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'." />
        <value name="SRC_BUS_ERROR" value="010" desc="Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_BUS_ERROR" value="011" desc="Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="SRC_MISAL" value="100" desc="Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="DST_MISAL" value="101" desc="Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
        <value name="INVALID" value="110" desc="Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error)." />
      </field>
      <field name="CURR_DATA_NR" from="15" to="0" access="RW" resetVal="" desc="Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: &#xA; - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 &#xA; - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 &#xA; - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 &#xA; HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 &#xA; This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses." hidden="false" />
    </register>
  </block>
  <block name="cy_lfclk" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="SmartIO" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false">
    <block name="VirtualMux_5" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="VirtualMux_4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="VirtualMux_7" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="VirtualMux_6" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="VirtualMux_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="VirtualMux_0" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_m0s8_prgio" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="VirtualMux_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="VirtualMux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  </block>
  <block name="cy_boot" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="D4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="D11" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="MB2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="D5" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="GND_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="PWR_4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="SW_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="SW_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="R_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="R_7" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="R_6" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="PWR_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="R_8" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="D_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="D_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="R_5" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="D_4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="GPIO" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="CSINTR" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="EZI2C" BASE="0x0" SIZE="0x0" desc="Serial Communication Block" visible="true" hidden="false">
    <block name="sclk_s_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="clock_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="miso_m_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="mosi_s_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="select_s_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="SCBCLK" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="rx_wake_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="rx_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cts_VM" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="SCB_IRQ" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="Device_VM4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="SCB" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="scl" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sda" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="or_sclk" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_7" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <register name="_CTRL" address="0x40090000" bitWidth="32" desc="Generic control register" hidden="false">
      <field name="OVS" from="3" to="0" access="RW" resetVal="" desc="Serial interface bit period oversampling factor expressed in lP clock cycles. Used for SPI and UART functionality. OVS + 1 IP clock cycles constitute a single serial interface clock/bit cycle." hidden="false" />
      <field name="EC_AM_MODE" from="8" to="8" access="RW" resetVal="" desc="Internally clocked mode ('0') or externally clocked mode ('1') address matching (I2C) or selection (SPI).In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface." hidden="false" />
      <field name="EC_OP_MODE" from="9" to="9" access="RW" resetVal="" desc="Internally clocked mode ('0') or externally clocked mode ('1') operation. In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface." hidden="false" />
      <field name="EZ_MODE" from="10" to="10" access="RW" resetVal="" desc="Non EZ mode ('0') or EZ mode ('1'). In EZ mode, a meta protocol is applied to the serial interface protocol." hidden="false" />
      <field name="BYTE_MODE" from="11" to="11" access="RW" resetVal="" desc="Determines the number of bits per FIFO data element: '0' - 16-bit FIFO data elements (FIFO entries 8), '1' - 8-bit FIFO data elements (FIFO entries 16). Setting data elemelents to 8-bits doubles the amount of FIFO entries." hidden="false" />
      <field name="ADDR_ACCEPT" from="16" to="16" access="RW" resetVal="" desc="Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').his field is used in the I2C mode." hidden="false" />
      <field name="BLOCK" from="17" to="17" access="RW" resetVal="" desc=" If the externally clocked logic and the MMIO SW accesses to EZ memory coincide/collide, this bit determines whether a SW access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0')" hidden="false" />
      <field name="MODE" from="25" to="24" access="RW" resetVal="" desc="Mode of operation: I2C = 0, SPI = 1, UART = 2" hidden="false" />
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="IP enabled ('1') or not ('0')." hidden="false" />
    </register>
    <register name="_SPI_CTRL" address="0x40090020" bitWidth="32" desc="SPI control register" hidden="false">
      <field name="CONTINUOUS" from="0" to="0" access="RW" resetVal="" desc="Continuous SPI data transfers enabled ('1') or not ('0')." hidden="false" />
      <field name="SELECT_PRECEDE" from="1" to="1" access="RW" resetVal="" desc="Only used in SPI Texas Instruments' submode. When '1', the data frame start indication is a pulse on the SELECT line that precedes the transfer of the first data frame bit. When '0', the data frame start indication is a pulse on the SELECT line that coincides with the transfer of the first data frame bit." hidden="false" />
      <field name="CPHA" from="2" to="2" access="RW" resetVal="" desc="Only applicable in SPI Motorola submode. Indicates the clock phase." hidden="false" />
      <field name="CPOL" from="3" to="3" access="RW" resetVal="" desc="Only applicable in SPI Motorola submode. Indicates the clock polarity." hidden="false" />
      <field name="LATE_MISO_SAMPLE" from="4" to="4" access="RW" resetVal="" desc="Only applicable in master mode. Changes the SCLK edge on which MISO is captured." hidden="false" />
      <field name="SCLK_CONTINUOUS" from="5" to="5" access="RW" resetVal="" desc="Enables SCLK generation continuiusly by master regars data is avaiable in TX FIFO or not." hidden="false" />
      <field name="SSEL_POLARITY0" from="8" to="8" access="RW" resetVal="" desc="Slave select polarity of SS0." hidden="false" />
      <field name="SSEL_POLARITY1" from="9" to="9" access="RW" resetVal="" desc="Slave select polarity of SS1." hidden="false" />
      <field name="SSEL_POLARITY2" from="10" to="10" access="RW" resetVal="" desc="Slave select polarity of SS2." hidden="false" />
      <field name="SSEL_POLARITY3" from="11" to="11" access="RW" resetVal="" desc="Slave select polarity of SS3." hidden="false" />
      <field name="LOOPBACK" from="16" to="16" access="RW" resetVal="" desc="Local loopback control." hidden="false" />
      <field name="MODE" from="25" to="24" access="RW" resetVal="" desc="Submode of SPI operation: Motorola = 0, Texas Instruments = 1, National Semiconducturs = 2." hidden="false" />
      <field name="SLAVE_SELECT" from="27" to="26" access="RW" resetVal="" desc="Selects one of the four SPI slave select signals: SS0 = 0, SS1 = 1 , SS2 = 2, SS3 = 3." hidden="false" />
      <field name="MASTER_MODE" from="31" to="31" access="RW" resetVal="" desc="Master ('1') or slave ('0') mode." hidden="false" />
    </register>
    <register name="_SPI_STATUS" address="0x40090024" bitWidth="32" desc="SPI status register" hidden="false">
      <field name="BUS_BUSY" from="0" to="0" access="R" resetVal="" desc="SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction" hidden="false" />
    </register>
    <register name="_UART_CTRL" address="0x40090040" bitWidth="32" desc="UART control register" hidden="false">
      <field name="LOOPBACK" from="16" to="16" access="RW" resetVal="" desc="Local loopback control." hidden="false" />
      <field name="MODE" from="25" to="24" access="RW" resetVal="" desc="Submode of UART operation: Standard = 0, Smart Card = 1, IrDA = 2." hidden="false" />
    </register>
    <register name="_UART_TX_CTRL" address="0x40090044" bitWidth="32" desc="UART transmitter control register" hidden="false">
      <field name="STOP_BTIS" from="2" to="0" access="RW" resetVal="" desc="Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods." hidden="false" />
      <field name="PARITY" from="4" to="4" access="RW" resetVal="" desc="Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity" hidden="false" />
      <field name="PARITY_ENABLED" from="5" to="5" access="RW" resetVal="" desc="Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware." hidden="false" />
      <field name="RETRY_ON_NACK" from="8" to="8" access="RW" resetVal="" desc="When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode." hidden="false" />
    </register>
    <register name="_UART_RX_CTRL" address="0x40090048" bitWidth="32" desc="UART receiver control register" hidden="false">
      <field name="STOP_BITS" from="2" to="0" access="RW" resetVal="" desc="Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods." hidden="false" />
      <field name="PARITY" from="4" to="4" access="RW" resetVal="" desc="Parity bit. When '0', the receiver expects an even parity. When '1', the receiver expects an odd parity." hidden="false" />
      <field name="PARITY_ENABLED" from="5" to="5" access="RW" resetVal="" desc="Parity checking enabled ('1') or not ('0'). Only applicable in standard UART submode. In SmartCard submode, parity checking is always enabled through hardware. In IrDA submode, parity checking is always disabled through hardware." hidden="false" />
      <field name="POLARITY" from="6" to="6" access="RW" resetVal="" desc="Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality." hidden="false" />
      <field name="DROP_ON_PARITY_ERR" from="8" to="8" access="RW" resetVal="" desc="Behaviour when a parity check fails. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost." hidden="false" />
      <field name="DROP_ON_FRAME_ERR" from="9" to="9" access="RW" resetVal="" desc="Behaviour when an error is detected in a start or stop period. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost." hidden="false" />
      <field name="MP_MODE" from="10" to="10" access="RW" resetVal="" desc="Multi-processor mode. When '1', multi-processor mode is enabled. In this mode, RX_CTRL.DATA_WIDTH should indicate a 9-bit data frame." hidden="false" />
      <field name="LIN_MODE" from="12" to="12" access="RW" resetVal="" desc="Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data" hidden="false" />
      <field name="SKIP_START" from="13" to="13" access="RW" resetVal="" desc="Only applicable in standard UART submode. When '1', the receiver skips start bit detection for the first received data frame. Instead, it synchronizes on the first received data frame bit, which should be a '1'." hidden="false" />
      <field name="BREAK_WIDTH" from="19" to="16" access="RW" resetVal="" desc="Break width. BREAK_WIDTH + 1 is the minimum width in bit periods of a break." hidden="false" />
    </register>
    <register name="_UART_FLOW_CTRL" address="0x40090050" bitWidth="32" desc="UART flow control register" hidden="false">
      <field name="TRIGGER_LEVEL" from="3" to="0" access="RW" resetVal="" desc="Trigger level. When the receiver FIFO has less entries than the amount of this field, a RTS signal is activated. Setting this field to 0 disables RTS generation." hidden="false" />
      <field name="RTS_POLARITY" from="16" to="16" access="RW" resetVal="" desc="Polarity of the RTS output signal" hidden="false" />
      <field name="CTS_POLARITY" from="24" to="24" access="RW" resetVal="" desc="Polarity of the CTS input signal" hidden="false" />
      <field name="CTS_ENABLED" from="25" to="25" access="RW" resetVal="" desc="Enable use of CTS input signal by the UART transmitter" hidden="false" />
    </register>
    <register name="_I2C_CTRL" address="0x40090060" bitWidth="32" desc="I2C control register" hidden="false">
      <field name="HIGH_PHASE_OVS" from="3" to="0" access="RW" resetVal="" desc="Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 peripheral clock periods constitute the high phase of a bit period." hidden="false" />
      <field name="LOW_PHASE_OVS" from="7" to="4" access="RW" resetVal="" desc="Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 peripheral clock periods constitute the low phase of a bit period" hidden="false" />
      <field name="M_READY_DATA_ACK" from="8" to="8" access="RW" resetVal="" desc="When '1', a received data element by the master is immediately ACK'd when the receiver FIFO is not full." hidden="false" />
      <field name="M_NOT_READY_DATA_NACK" from="9" to="9" access="RW" resetVal="" desc="When '1', a received data element byte the master is immediately NACK'd when the receiver FIFO is full. When '0', clock stretching is used instead (till the receiver FIFO is no longer full)." hidden="false" />
      <field name="S_GENERAL_IGNORE" from="11" to="11" access="RW" resetVal="" desc="When '1', a received general call slave address is immediately NACK'd (no ACK or clock stretching) and treated as a non matching slave address." hidden="false" />
      <field name="S_READY_ADDR_ACK" from="12" to="12" access="RW" resetVal="" desc="When '1', a received (matching) slave address is immediately ACK'd when the receiver FIFO is not full" hidden="false" />
      <field name="S_READY_DATA_ACK" from="13" to="13" access="RW" resetVal="" desc="When '1', a received data element by the slave is immediately ACK'd when the receiver FIFO is not full" hidden="false" />
      <field name="S_NOT_READY_ADDR_NACK" from="14" to="14" access="RW" resetVal="" desc="When '1', a received address by the slave is immediately ACK'd when the receiver FIFO is not full" hidden="false" />
      <field name="S_NOT_READY_DATA_NACK" from="15" to="15" access="RW" resetVal="" desc=" When '1' a received data element byte the slave is immediately NACK'd when the receiver FIFO is full. When '1' clock stretching is performed (till the receiver FIFO is no longer full)." hidden="false" />
      <field name="LOOPBACK" from="16" to="16" access="RW" resetVal="" desc="Local loopback control" hidden="false" />
      <field name="SLAVE_MODE" from="30" to="30" access="RW" resetVal="" desc="Slave mode enabled ('1') or not ('0')." hidden="false" />
      <field name="MASTER_MODE" from="31" to="31" access="RW" resetVal="" desc="Master mode enabled ('1') or not ('0'). Note that both master and slave modes can be enabled at the same time. This allows the IP to address itself." hidden="false" />
    </register>
    <register name="_I2C_STATUS" address="0x40090064" bitWidth="32" desc="I2C status register" hidden="false">
      <field name="BUS_BUSY" from="0" to="0" access="R" resetVal="" desc="I2C bus is busy. The bus is considered busy ('1')." hidden="false" />
      <field name="S_READ" from="4" to="4" access="R" resetVal="" desc="I2C slave read transfer ('1') or I2C slave write transfer ('0'). When the I2C slave is inactive/idle or receiving START, REPEATED START, STOP or an address, this field is '0'." hidden="false" />
      <field name="M_READ" from="5" to="5" access="R" resetVal="" desc="I2C master read transfer ('1') or I2C master write transfer ('0'). When the I2C master is inactive/idle or transmitting START, REPEATED START, STOP or an address, this field is '0''." hidden="false" />
    </register>
    <register name="_I2C_M_CMD" address="0x40090068" bitWidth="32" desc="I2C master command register" hidden="false">
      <field name="M_START" from="0" to="0" access="RW" resetVal="" desc="When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. When this action is performed, the hardware sets this field to '0'." hidden="false" />
      <field name="M_IDLE_START" from="1" to="1" access="RW" resetVal="" desc="When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). When this action is performed, the hardware sets this field to '0'." hidden="false" />
      <field name="M_ACK" from="2" to="2" access="RW" resetVal="" desc="When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'." hidden="false" />
      <field name="M_NACK" from="3" to="3" access="RW" resetVal="" desc="When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'." hidden="false" />
      <field name="M_STOP" from="4" to="4" access="RW" resetVal="" desc="When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. This command has a higher priority than I2C_M_CMD.M_START: in situations where both a STOP and a REPEATED START could be transmitted, M_STOP takes precedence over M_START." hidden="false" />
    </register>
    <register name="_I2C_S_CMD" address="0x4009006C" bitWidth="32" desc="I2C slave command register" hidden="false">
      <field name="S_ACK" from="0" to="0" access="RW" resetVal="" desc="When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'." hidden="false" />
      <field name="S_NACK" from="1" to="1" access="RW" resetVal="" desc="When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'" hidden="false" />
    </register>
    <register name="_I2C_CFG" address="0x40090070" bitWidth="32" desc="I2C fitler trimm register" hidden="false">
      <field name="SDA_IN_FILT_TRIM" from="1" to="0" access="RW" resetVal="" desc="" hidden="false" />
      <field name="SDA_IN_FILT_SEL" from="4" to="4" access="RW" resetVal="" desc="" hidden="false" />
      <field name="SCL_IN_FILT_TRIM" from="9" to="8" access="RW" resetVal="" desc="" hidden="false" />
      <field name="SCL_IN_FILT_SEL" from="12" to="12" access="RW" resetVal="" desc="" hidden="false" />
      <field name="SDA_OUT_FILT0_TRIM" from="17" to="16" access="RW" resetVal="" desc="" hidden="false" />
      <field name="SDA_OUT_FILT1_TRIM" from="19" to="18" access="RW" resetVal="" desc="" hidden="false" />
      <field name="SDA_OUT_FILT2_TRIM" from="21" to="20" access="RW" resetVal="" desc="" hidden="false" />
      <field name="SDA_OUT_FILT_SEL" from="29" to="28" access="RW" resetVal="" desc="" hidden="false" />
    </register>
    <register name="_TX_CTRL" address="0x40090200" bitWidth="32" desc="Transmitter control register" hidden="false">
      <field name="DATA_WIDTH" from="3" to="0" access="RW" resetVal="" desc="Data frame width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame." hidden="false" />
      <field name="MSB_FIRST" from="8" to="8" access="RW" resetVal="" desc="Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'." hidden="false" />
    </register>
    <register name="_TX_FIFO_CTRL" address="0x40090204" bitWidth="32" desc="Transmitter FIFO control register" hidden="false">
      <field name="TRIGGER_LEVEL" from="3" to="0" access="RW" resetVal="" desc="Trigger level. When the transmitter FIFO has less entries than the amount of this field, a transmitter trigger event is generated." hidden="false" />
      <field name="CLEAR" from="16" to="16" access="RW" resetVal="" desc="When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period." hidden="false" />
      <field name="FREEZE" from="17" to="17" access="RW" resetVal="" desc="When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer." hidden="false" />
    </register>
    <register name="_TX_FIFO_STATUS" address="0x40090208" bitWidth="32" desc="Transmitter FIFO status register" hidden="false">
      <field name="USED" from="4" to="0" access="R" resetVal="" desc="Amount of entries in the transmitter FIFO. The value of this field ranges from 0 to 8." hidden="false" />
      <field name="SR_VALID" from="15" to="15" access="R" resetVal="" desc="Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0')" hidden="false" />
      <field name="RD_PTR" from="20" to="16" access="R" resetVal="" desc="FIFO read pointer: FIFO location from which a data frame is read by the hardware." hidden="false" />
      <field name="WR_PTR" from="28" to="24" access="R" resetVal="" desc="FIFO write pointer: FIFO location at which a new data frame is written." hidden="false" />
    </register>
    <register name="_TX_FIFO_WR" address="0x40090240" bitWidth="32" desc="Transmitter FIFO write register" hidden="false">
      <field name="DATA" from="15" to="0" access="W" resetVal="" desc="Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation." hidden="false" />
    </register>
    <register name="_RX_CTRL" address="0x40090300" bitWidth="32" desc="Receiver control register" hidden="false">
      <field name="DATA_WIDTH" from="3" to="0" access="RW" resetVal="" desc="Data frame width. DATA_WIDTH + 1 is the expected amount of bits in received data frame." hidden="false" />
      <field name="MSB_FIRST" from="8" to="8" access="RW" resetVal="" desc="Least significant bit first ('0') or most significant bit first ('1')." hidden="false" />
      <field name="MEDIAN" from="9" to="9" access="RW" resetVal="" desc="Median filter. When '1', a digital 3 taps median filter is performed on input interface lines." hidden="false" />
    </register>
    <register name="_RX_FIFO_CTRL" address="0x40090304" bitWidth="32" desc="Receiver FIFO control register" hidden="false">
      <field name="TRIGGER_LEVEL" from="3" to="0" access="RW" resetVal="" desc="Trigger level. When the receiver FIFO has more entries than the amount of this field, a receiver trigger event is generated." hidden="false" />
      <field name="CLEAR" from="16" to="16" access="RW" resetVal="" desc="When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period." hidden="false" />
      <field name="FREEZE" from="17" to="17" access="RW" resetVal="" desc="When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer." hidden="false" />
    </register>
    <register name="_RX_FIFO_STATUS" address="0x40090308" bitWidth="32" desc="Receiver FIFO status registerS" hidden="false">
      <field name="USED" from="4" to="0" access="R" resetVal="" desc="Amount of entries in the receiver FIFO. The value of this field ranges from 0 to 8." hidden="false" />
      <field name="SR_VALID" from="15" to="15" access="R" resetVal="" desc="Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0')." hidden="false" />
      <field name="RD_PTR" from="20" to="16" access="R" resetVal="" desc="FIFO read pointer: FIFO location from which a data frame is read." hidden="false" />
      <field name="WR_PTR" from="28" to="24" access="R" resetVal="" desc="FIFO write pointer: FIFO location at which a new data frame is written by the hardware." hidden="false" />
    </register>
    <register name="_RX_MATCH" address="0x40090310" bitWidth="32" desc="Slave address and mask register" hidden="false">
      <field name="ADDR" from="7" to="0" access="RW" resetVal="" desc="Slave device address. For UART multi-processor mode all eight bits a reused. For I2C, bit 0 of the register is not used." hidden="false" />
      <field name="MASK" from="23" to="16" access="RW" resetVal="" desc="Slave device address mask. This field is a 8 bit mask that specifies which of the ADDR field bits in the SCB_RX_MATCH_ADDR register take part in the matching of the slave address." hidden="false" />
    </register>
    <register name="_RX_FIFO_RD" address="0x40090340" bitWidth="32" desc="Receiver FIFO read register" hidden="false">
      <field name="DATA" from="15" to="0" access="R" resetVal="" desc="Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO." hidden="false" />
    </register>
    <register name="_INTR_CAUSE" address="0x40090E00" bitWidth="32" desc="Interrupt cause register" hidden="false">
      <field name="MASTER" from="0" to="0" access="R" resetVal="" desc="Master interrupt active." hidden="false" />
      <field name="SLAVE" from="1" to="1" access="R" resetVal="" desc="Slave interrupt active." hidden="false" />
      <field name="TX" from="2" to="2" access="R" resetVal="" desc="Transmitter interrupt active." hidden="false" />
      <field name="RX" from="3" to="3" access="R" resetVal="" desc="Receiver interrupt active." hidden="false" />
      <field name="I2C_EC" from="4" to="4" access="R" resetVal="" desc="Externally clock I2C interrupt active." hidden="false" />
      <field name="SPI_EC" from="5" to="5" access="R" resetVal="" desc="Externally clocked SPI interrupt active." hidden="false" />
    </register>
    <register name="_INTR_I2C_EC" address="0x40090E80" bitWidth="32" desc="Externally clocked I2C interrupt request register" hidden="false">
      <field name="WAKE_UP" from="0" to="0" access="RW" resetVal="" desc="Wake up request. Active on incoming slave request (with address match). Only used when EC_AM is '1'." hidden="false" />
    </register>
    <register name="_INTR_I2C_EC_MASK" address="0x40090E88" bitWidth="32" desc="Externally clocked I2C interrupt mask register" hidden="false">
      <field name="WAKE_UP" from="0" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_I2C_EC_MASKED" address="0x40090E8C" bitWidth="32" desc="Externally clocked SPI interrupt masked register" hidden="false">
      <field name="WAKE_UP" from="0" to="0" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
    </register>
    <register name="_INTR_INTR_SPI_EC" address="0x40090EC0" bitWidth="32" desc="Externally clocked SPI interrupt request register" hidden="false">
      <field name="WAKE_UP" from="0" to="0" access="RW" resetVal="" desc="Wake up request. Active on incoming slave request when externally clocked selection is '1'." hidden="false" />
    </register>
    <register name="_INTR_INTR_SPI_EC_MASK" address="0x40090EC8" bitWidth="32" desc="Externally clocked SPI interrupt mask register" hidden="false">
      <field name="WAKE_UP" from="0" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_INTR_SPI_EC_MASKED" address="0x40090ECC" bitWidth="32" desc="Externally clocked SPI interrupt masked register" hidden="false">
      <field name="WAKE_UP" from="0" to="0" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
    </register>
    <register name="_INTR_M" address="0x40090F00" bitWidth="32" desc="Master interrupt request register." hidden="false">
      <field name="I2C_LOST_ARB" from="0" to="0" access="RW" resetVal="" desc="I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data)." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data)." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="I2C master STOP. Set to '1', when the master has transmitted a STOP." hidden="false" />
      <field name="I2C_BUS_ERR" from="8" to="8" access="RW" resetVal="" desc="I2C master bus error (unexpected detection of START or STOP condition)." hidden="false" />
      <field name="SPI_DONE" from="9" to="9" access="RW" resetVal="" desc="SPI master transfer done event: all data frames in the transmit FIFO are sent and the transmit FIFO is empty." hidden="false" />
    </register>
    <register name="_INTR_M_SET" address="0x40090F04" bitWidth="32" desc="Master interrupt set request register" hidden="false">
      <field name="I2C_LOST_ARB" from="0" to="0" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_BUS_ERR" from="8" to="8" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="SPI_DONE" from="9" to="9" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_M_MASK" address="0x40090F08" bitWidth="32" desc="Master interrupt mask register" hidden="false">
      <field name="I2C_LOST_ARB" from="0" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_BUS_ERR" from="8" to="8" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="SPI_DONE" from="9" to="9" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_M_MASKED" address="0x40090F0C" bitWidth="32" desc="Master interrupt masked request register" hidden="false">
      <field name="I2C_LOST_ARB" from="0" to="0" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_BUS_ERR" from="8" to="8" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="SPI_DONE" from="9" to="9" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
    </register>
    <register name="_INTR_S" address="0x40090F40" bitWidth="32" desc="Slave interrupt request register" hidden="false">
      <field name="I2C_ARB_LOST" from="0" to="0" access="RW" resetVal="" desc="I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1')." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="I2C slave negative acknowledgement received. Set to '1', when the slave receives a NACK (typically after the slave transmitted TX data)." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="I2C slave acknowledgement received. Set to '1', when the slave receives a ACK (typically after the slave transmitted TX data)." hidden="false" />
      <field name="I2C_WRITE_STOP" from="3" to="3" access="RW" resetVal="" desc="I2C STOP event for I2C write transfer intended for this slave (address matching is performed).Set to '1', when STOP or REPEATED START event is detected." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="I2C STOP event for I2C (read or write) transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected" hidden="false" />
      <field name="I2C_START" from="5" to="5" access="RW" resetVal="" desc="I2C slave START received. Set to '1', when START or REPEATED START event is detected." hidden="false" />
      <field name="I2C_ADDR_MATCH" from="6" to="6" access="RW" resetVal="" desc="I2C slave matching address received. If CTRL.ADDR_ACCEPT, the received address (including the R/W bit) is available in the RX FIFO." hidden="false" />
      <field name="I2C_GENERAL" from="7" to="7" access="RW" resetVal="" desc="I2C slave general call address received.  If CTRL.ADDR_ACCEPT, the received address 0x00 (including the R/W bit) is available in the RX FIFO" hidden="false" />
      <field name="I2C_BUS_ERR" from="8" to="8" access="RW" resetVal="" desc="I2C slave bus error (unexpected detection of START or STOP condition)." hidden="false" />
      <field name="SPI_BUS_ERR" from="11" to="11" access="RW" resetVal="" desc="SPI slave deselected at an unexpected time in the SPI transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error." hidden="false" />
    </register>
    <register name="_INTR_S_SET" address="0x40090F44" bitWidth="32" desc="Slave interrupt set request register" hidden="false">
      <field name="I2C_ARB_LOST" from="0" to="0" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_WRITE_STOP" from="3" to="3" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_START" from="5" to="5" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_ADDR_MATCH" from="6" to="6" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_GENERAL" from="7" to="7" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_BUS_ERR" from="8" to="8" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="SPI_BUS_ERR" from="11" to="11" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_S_MASK" address="0x40090F48" bitWidth="32" desc="Slave interrupt mask register" hidden="false">
      <field name="I2C_ARB_LOST" from="0" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_WRITE_STOP" from="3" to="3" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_START" from="5" to="5" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_ADDR_MATCH" from="6" to="6" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_GENERAL" from="7" to="7" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="I2C_BUS_ERR" from="8" to="8" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="SPI_BUS_ERR" from="11" to="11" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_S_MASKED" address="0x40090F4C" bitWidth="32" desc="Slave interrupt masked register" hidden="false">
      <field name="I2C_ARB_LOST" from="0" to="0" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_NACK" from="1" to="1" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_ACK" from="2" to="2" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_WRITE_STOP" from="3" to="3" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_STOP" from="4" to="4" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_START" from="5" to="5" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_ADDR_MATCH" from="6" to="6" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="I2C_GENERAL" from="7" to="7" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="SPI_BUS_ERR" from="11" to="11" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
    </register>
    <register name="_INTR_TX" address="0x40090F80" bitWidth="32" desc="Transmitter interrupt request register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="Less entries in the TX FIFO than the value specified by TRIGGER_LEVEL in SCB_TX_FIFO_CTL." hidden="false" />
      <field name="NOT_FULL" from="1" to="1" access="RW" resetVal="" desc="TX FIFO is not full." hidden="false" />
      <field name="EMPTY" from="4" to="4" access="RW" resetVal="" desc="TX FIFO is empty; i.e. it has 0 entries." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Attempt to write to a full TX FIFO." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Attempt to read from an empty TX FIFO." hidden="false" />
      <field name="UART_NACK" from="8" to="8" access="RW" resetVal="" desc="UART transmitter received a negative acknowledgement in SmartCard mode. Set to '1', when event is detected." hidden="false" />
      <field name="UART_DONE" from="9" to="9" access="RW" resetVal="" desc="UART transmitter done event. This happens when the IP is done transferring all data in the TX FIFO; i.e. EMPTY is '1'. Set to '1', when event is detected." hidden="false" />
      <field name="UART_ARB_LOST" from="10" to="10" access="RW" resetVal="" desc="UART lost arbitration: the value driven on the TX line is not the same as the value observed on the RX line. " hidden="false" />
    </register>
    <register name="_INTR_TX_SET" address="0x40090F84" bitWidth="32" desc="Transmitter interrupt set request register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="NOT_FULL" from="1" to="1" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="EMPTY" from="4" to="4" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="UART_NACK" from="8" to="8" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="UART_DONE" from="9" to="9" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="UART_ARB_LOST" from="10" to="10" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_TX_MASK" address="0x40090F88" bitWidth="32" desc="Transmitter interrupt mask request register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="NOT_FULL" from="1" to="1" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="EMPTY" from="4" to="4" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="UART_NACK" from="8" to="8" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="UART_DONE" from="9" to="9" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="UART_ARB_LOST" from="10" to="10" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_TX_MASKED" address="0x40090F8C" bitWidth="32" desc="Transmitter interrupt masked request register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="NOT_FULL" from="1" to="1" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="EMPTY" from="4" to="4" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="UART_NACK" from="8" to="8" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="UART_DONE" from="9" to="9" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="UART_ARB_LOST" from="10" to="10" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
    </register>
    <register name="_INTR_RX" address="0x40090FC0" bitWidth="32" desc="Receiver interrupt request register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="More entries in the RX FIFO than the value specified by TRIGGER_LEVEL in SCB_RX_FIFO_CTL." hidden="false" />
      <field name="NOT_EMPTY" from="2" to="2" access="RW" resetVal="" desc="RX FIFO is not empty." hidden="false" />
      <field name="FULL" from="3" to="3" access="RW" resetVal="" desc="RX FIFO is full. Note that received data frames are lost when the RX FIFO is full." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Attempt to write to a full RX FIFO. Note: in I2C mode, the OVERFLOW is set when a data frame is received and the RX FIFO is full, independent of whether it is ACK'd or NACK'd." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Attempt to read from an empty RX FIFO." hidden="false" />
      <field name="FRAME_ERR" from="8" to="8" access="RW" resetVal="" desc="Frame error in received data frame. Set to '1', when event is detected." hidden="false" />
      <field name="PARITY_ERR" from="9" to="9" access="RW" resetVal="" desc="Parity error in received data frame. Set to '1', when event is detected." hidden="false" />
      <field name="BAUD_DETECT" from="10" to="10" access="RW" resetVal="" desc="LIN baud rate detection is completed." hidden="false" />
      <field name="BREAK_DETECT" from="11" to="11" access="RW" resetVal="" desc="Break detection is successful: the line is '0' for UART_RX_CTRL.BREAK_WIDTH + 1 bit period." hidden="false" />
    </register>
    <register name="_INTR_RX_SET" address="0x40090FC4" bitWidth="32" desc="Receiver interrupt set request register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="NOT_EMPTY" from="2" to="2" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="FULL" from="3" to="3" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="FRAME_ERR" from="8" to="8" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="PARITY_ERR" from="9" to="9" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="BAUD_DETECT" from="10" to="10" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="BREAK_DETECT" from="11" to="11" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_RX_MASK" address="0x40090FC8" bitWidth="32" desc="Receiver interrupt mask register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="NOT_EMPTY" from="2" to="2" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="FULL" from="3" to="3" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="FRAME_ERR" from="8" to="8" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="PARITY_ERR" from="9" to="9" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="BAUD_DETECT" from="10" to="10" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="BREAK_DETECT" from="11" to="11" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="_INTR_RX_MASKED" address="0x40090FCC" bitWidth="32" desc="Receiver interrupt masked register" hidden="false">
      <field name="TRIGGER" from="0" to="0" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="NOT_EMPTY" from="2" to="2" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="FULL" from="3" to="3" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="OVERFLOW" from="5" to="5" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="UNDERFLOW" from="6" to="6" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="FRAME_ERR" from="8" to="8" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits" hidden="false" />
      <field name="PARITY_ERR" from="9" to="9" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits" hidden="false" />
      <field name="BAUD_DETECT" from="10" to="10" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits" hidden="false" />
      <field name="BREAK_DETECT" from="11" to="11" access="RW" resetVal="" desc="Logical and of corresponding request and mask bits" hidden="false" />
    </register>
  </block>
  <block name="Bootloadable" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="PROXLED" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="CapSense" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false">
    <block name="ZeroTerminal_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_6" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_5" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="Sns" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="CSD" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ISR" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="IDACComp" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="IDACMod" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_virtualmux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_13" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ModClk" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_12" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_virtualmux_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="or_ModClk" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="Cmod" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_8" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_7" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_11" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_10" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_9" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <register name="GROUP_CSDV2_CONFIG" address="0x400C0000" bitWidth="32" desc="Configuration and Control" hidden="false">
      <field name="FILTER_DELAY" from="6" to="4" access="RW" resetVal="" desc="This value determines the number of cycles that the digital filter makes the CSDCMP output ignored while the counter counts and IDAC is on. &#xA;When set to 0 the digital filter is off. When set to any other value the ignoring will last for FILTER_DELAY clk_csd cycles after the start of each measurement and from the first comparator trip to the end of each measurement." hidden="false" />
      <field name="SHIELD_DELAY" from="9" to="8" access="RW" resetVal="" desc="Selects the delay by which csd_shield is delayed relative to csd_sense." hidden="false">
        <value name="OFF" value="0" desc="Delay line is off, csd_shield=csd_sense" />
        <value name="D5NS" value="1" desc="Introduces a 5ns delay (typ)" />
        <value name="D10NS" value="10" desc="Introduces a 10ns delay (typ)" />
        <value name="D20NS" value="11" desc="Introduces a 20ns delay (typ)" />
      </field>
      <field name="SENSE_EN" from="12" to="12" access="RW" resetVal="" desc="Enables the sense modulator output. &#xA;0: all switches, static or dynamic, are open and IDAC in CSD mode is off&#xA;1: switches and IDAC can be closed/on as per MMIO setting and CSD sequencer." hidden="false" />
      <field name="CHARGE_MODE" from="14" to="14" access="RW" resetVal="" desc="Enable charging of the Cmod/Csh_tank capacitor using the GPIO digital output buffer using the csd_charge signal.  Note that using the GPIO requires proper configuraiton of the GPIO pin." hidden="false">
        <value name="CHARGE_OFF" value="0" desc="Use this to keep csd_charge signal low. For charging Cmod/Csh_tank capacitor CSD internal switches (HCBV) can be used but that is a separate configuration." />
        <value name="CHARGE_IO" value="1" desc="Use csd_charge to enable the GPIO Driver to charge capacitor.  The capacitor must be  sensed with HSCMP using the appropriate switches (HMPM or HMPT)." />
      </field>
      <field name="MUTUAL_CAP" from="18" to="18" access="RW" resetVal="" desc="Enables mutual cap sensing mode" hidden="false">
        <value name="SELFCAP" value="0" desc="Self-cap mode (configure sense line as CSD_SENSE)" />
        <value name="MUTUALCAP" value="1" desc="Mutual-cap mode (configure Tx line as CSD_SENSE, inverted Tx line as CSD_SHIELD and Rx Line as AMUXA). In this mode the polarity bit of the IDAC is controlled by csd_sense." />
      </field>
      <field name="CSX_DUAL_CNT" from="19" to="19" access="RW" resetVal="" desc="Enable the use of two counters for MUTUAL cap sensing mode (CSX), do not use when MUTUAL_CAP=0" hidden="false">
        <value name="ONE" value="0" desc="Use one counter for both phases (source and sink)." />
        <value name="TWO" value="1" desc="Use two counters, separate count for when csd_sense is high and when csd_sense is low." />
      </field>
      <field name="DSI_COUNT_SEL" from="24" to="24" access="RW" resetVal="" desc="Select what to output  on the dsi_count bus." hidden="false">
        <value name="CSD_RESULT" value="0" desc="depending on the dsi_count_val_sel input either output  RESULT_VAL1.VALUE (0) or RESULT_VAL2.VALUE (1) on the dsi_count bus. Note that dsi_count_val_sel is not synchronized, i.e. it controls the mux combinatorially." />
        <value name="ADC_RESULT" value="1" desc="output ADC_RES.VIN_CNT on the dsi_count bus" />
      </field>
      <field name="DSI_SAMPLE_EN" from="25" to="25" access="RW" resetVal="" desc="Enables the use of the dsi_sample_in input instead of the comparator output to strobe COUNTER." hidden="false" />
      <field name="SAMPLE_SYNC" from="26" to="26" access="RW" resetVal="" desc="Enables double synchronizing of sample input from DSI (only relevant when DSI_SAMPLE_EN=1)." hidden="false" />
      <field name="DSI_SENSE_EN" from="27" to="27" access="RW" resetVal="" desc="Enables the use of the dsi_sense_in input instead of the internally generated modulation signal to drive csd_sense and csd_shield signals." hidden="false" />
      <field name="LP_MODE" from="30" to="30" access="RW" resetVal="" desc="Select the power mode for the CSD components (REFGEN, AMBUF, CSDCMP, HSCMP):&#xA;0: High Power mode&#xA;1: Low Power mode" hidden="false" />
      <field name="ENABLE" from="31" to="31" access="RW" resetVal="" desc="Master enable of the CSDv2 IP.  Must be set to 1 for any CSDv2, ADC or IDAC operation to function.&#xA;When 0 all analog components will be off and all switches will be open." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SPARE" address="0x400C0004" bitWidth="32" desc="Spare MMIO" hidden="false">
      <field name="SPARE" from="3" to="0" access="RW" resetVal="" desc="Spare MMIO" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_STATUS" address="0x400C0080" bitWidth="32" desc="Status Register" hidden="false">
      <field name="CSD_CHARGE" from="0" to="0" access="R" resetVal="" desc="Qualified, and possible inverted value of COMP_OUT that is used to drive GPIO's charging Cmod or Csh_tank." hidden="false" />
      <field name="CSD_SENSE" from="1" to="1" access="R" resetVal="" desc="Signal used to drive the Cs switches." hidden="false" />
      <field name="HSCMP_OUT" from="2" to="2" access="R" resetVal="" desc="Output of reference buffer comparator used to charge up Cmod and/or Csh_tank (synchronized)" hidden="false">
        <value name="C_LT_VREF" value="0" desc="Vin &lt; Vref" />
        <value name="C_GT_VREF" value="1" desc="Vin &gt; Vref" />
      </field>
      <field name="CSDCMP_OUT" from="3" to="3" access="R" resetVal="" desc="Output of main sensing comparator (synchronized)" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_STAT_SEQ" address="0x400C0084" bitWidth="32" desc="Current Sequencer status" hidden="false">
      <field name="SEQ_STATE" from="2" to="0" access="R" resetVal="" desc="CSD sequencer state" hidden="false" />
      <field name="ADC_STATE" from="18" to="16" access="R" resetVal="" desc="ADC sequencer state (only relevant after SEQ_STATE has reached SAMPLE_NORM and ADC sequencer has started)" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_STAT_CNTS" address="0x400C0088" bitWidth="32" desc="Current status counts" hidden="false">
      <field name="NUM_CONV" from="15" to="0" access="R" resetVal="" desc="Current number of conversions remaining when in Sample_* states (note that in AutoZero* states the same down counter is reused to count the cycles)" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_RESULT_VAL1" address="0x400C00D0" bitWidth="32" desc="Result CSD/CSX accumulation counter value 1" hidden="false">
      <field name="VALUE" from="15" to="0" access="R" resetVal="" desc="Accumulated counter value for this result. In case of Mutual cap with two counters (CSX = config.mutual_cap &amp; config.csx_dual_cnt) this counter counts when csd_sense is high." hidden="false" />
      <field name="BAD_CONVS" from="23" to="16" access="R" resetVal="" desc="Number of 'bad' conversion for which the CSD comparator did not trigger within the normal time window, either because Vref was not crossed at all, or if the Vref was already crossed before the window started. This counter is reset when the sequencer is started and will saturate at 255 when more than 255 conversions are bad." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_RESULT_VAL2" address="0x400C00D4" bitWidth="32" desc="Result CSX accumulation counter value 2" hidden="false">
      <field name="VALUE" from="15" to="0" access="R" resetVal="" desc="Only used in case of Mutual cap with two counters (CSX = config.mutual_cap &amp; config.csx_dual_cnt), this counter counts when csd_sense is low." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_ADC_RES" address="0x400C00E0" bitWidth="32" desc="ADC measurement" hidden="false">
      <field name="VIN_CNT" from="15" to="0" access="R" resetVal="" desc="Count to source/sink Cref1 + Cref2 from Vin to Vrefhi. This is also the current counter value for the HSCMP counter" hidden="false" />
      <field name="HSCMP_POL" from="16" to="16" access="R" resetVal="" desc="Polarity used for IDACB for this last ADC result, 0= source, 1= sink" hidden="false" />
      <field name="ADC_OVERFLOW" from="30" to="30" access="R" resetVal="" desc="This flag is set when the ADC counter overflows. This is an indication to the firmware that the IDACB current level is too low." hidden="false" />
      <field name="ADC_ABORT" from="31" to="31" access="R" resetVal="" desc="This flag is set when the ADC sequencer was aborted before tripping HSCMP." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_INTR" address="0x400C00F0" bitWidth="32" desc="CSD Interrupt Request Register" hidden="false">
      <field name="SAMPLE" from="1" to="1" access="RW" resetVal="" desc="A normal sample is complete (CSDv1 compatible interrupt)" hidden="false" />
      <field name="INIT" from="2" to="2" access="RW" resetVal="" desc="Coarse initialization complete or Sample initialization complete (the latter is typically ignored)" hidden="false" />
      <field name="ADC_RES" from="8" to="8" access="RW" resetVal="" desc="ADC Result ready" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_INTR_SET" address="0x400C00F4" bitWidth="32" desc="CSD Interrupt set register" hidden="false">
      <field name="SAMPLE" from="1" to="1" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="INIT" from="2" to="2" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="ADC_RES" from="8" to="8" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_INTR_MASK" address="0x400C00F8" bitWidth="32" desc="CSD Interrupt mask register" hidden="false">
      <field name="SAMPLE" from="1" to="1" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="INIT" from="2" to="2" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="ADC_RES" from="8" to="8" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_INTR_MASKED" address="0x400C00FC" bitWidth="32" desc="CSD Interrupt masked register" hidden="false">
      <field name="SAMPLE" from="1" to="1" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="INIT" from="2" to="2" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="ADC_RES" from="8" to="8" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_HSCMP" address="0x400C0180" bitWidth="32" desc="High Speed Comparator configuration" hidden="false">
      <field name="HSCMP_EN" from="0" to="0" access="RW" resetVal="" desc="High Speed Comparator enable" hidden="false">
        <value name="OFF" value="0" desc="Disable comparator, output is zero" />
        <value name="ON" value="1" desc="On, regular operation. Note that CONFIG.LP_MODE determines the power mode level" />
      </field>
      <field name="HSCMP_INVERT" from="4" to="4" access="RW" resetVal="" desc="Invert the HSCMP output before it is used to control switches and the CSD sequencer. This bit does not affect the ADC sequencer or the STATUS.HSCMP_OUT" hidden="false" />
      <field name="AZ_EN" from="31" to="31" access="RW" resetVal="" desc="Auto-Zero enable, allow the Sequencer to Auto-Zero this component" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_AMBUF" address="0x400C0184" bitWidth="32" desc="Reference Generator configuration" hidden="false">
      <field name="PWR_MODE" from="1" to="0" access="RW" resetVal="" desc="Amux buffer power level" hidden="false">
        <value name="OFF" value="0" desc="Disable buffer" />
        <value name="NORM" value="1" desc="On, normal or low power level depending on CONFIG.LP_MODE." />
        <value name="HI" value="10" desc="On, high or low power level depending on CONFIG.LP_MODE." />
      </field>
    </register>
    <register name="GROUP_CSDV2_REFGEN" address="0x400C0188" bitWidth="32" desc="Reference Generator configuration" hidden="false">
      <field name="REFGEN_EN" from="0" to="0" access="RW" resetVal="" desc="Reference Generator Enable" hidden="false">
        <value name="OFF" value="0" desc="Disable Reference Generator" />
        <value name="ON" value="1" desc="On, regular operation. Note that CONFIG.LP_MODE determines the power mode level" />
      </field>
      <field name="BYPASS" from="4" to="4" access="RW" resetVal="" desc="Bypass selected input reference unbuffered to Vrefhi" hidden="false" />
      <field name="VDDA_EN" from="5" to="5" access="RW" resetVal="" desc="Close Vdda switch to top of resistor string (or Vrefhi?)" hidden="false" />
      <field name="RES_EN" from="6" to="6" access="RW" resetVal="" desc="Resistor string enable; 0= open switch on top of the resistor string (Vreflo=Vssa)" hidden="false" />
      <field name="GAIN" from="12" to="8" access="RW" resetVal="" desc="Select resistor string tap for feedback, 0= minimum vout, 31= maximum vout = vrefhi -&gt; gain=1  (only works if the resistor string is enabled; RES_EN=1)" hidden="false" />
      <field name="VREFLO_SEL" from="20" to="16" access="RW" resetVal="" desc="Select resistor string tap for Vreflo/Vreflo_int, 0= minimum vout, 31= maximum vout = vrefhi (only works if the resistor string is enabled; RES_EN=1)" hidden="false" />
      <field name="VREFLO_INT" from="23" to="23" access="RW" resetVal="" desc="Ouput the resistor string tap either to Vreflo (0) or Vreflo_int (1)." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_CSDCMP" address="0x400C018C" bitWidth="32" desc="CSD Comparator configuration" hidden="false">
      <field name="CSDCMP_EN" from="0" to="0" access="RW" resetVal="" desc="CSD Comparator Enable" hidden="false">
        <value name="OFF" value="0" desc="Disable comparator, output is zero" />
        <value name="ON" value="1" desc="On, regular operation. Note that CONFIG.LP_MODE determines the power mode level" />
      </field>
      <field name="POLARITY_SEL" from="5" to="4" access="RW" resetVal="" desc="Select which IDAC polarity to use to detect CSDCMP triggering" hidden="false">
        <value name="IDACA_POL" value="0" desc="Use idaca_pol (firmware setting with CSX and optionally DSI mixed in) to determine the direction, this is the most common use-case, used for normal CSD and normal CSX" />
        <value name="IDACB_POL" value="1" desc="Use idacb_pol (firmware setting with optional DSI mixed in) to determine the direction, this is only used for normal CSD if IDACB is used i.s.o. IDACA (not common)" />
        <value name="DUAL_POL" value="10" desc="Use the expression (csd_sense ? idaca_pol : idacb_pol)  to determine the direction, this is only useful for the CSX with DUAL_IDAC use-case" />
      </field>
      <field name="CMP_PHASE" from="9" to="8" access="RW" resetVal="" desc="Select in what phase(s) the comparator is active. Note, this also determines when a bad conversion is detected, namely at the beginning and end of the comparator active phase (also taking into account FILTER_DELAY and non-overlap)." hidden="false">
        <value name="FULL" value="0" desc="Comparator is active from start of Phi2 and kept active into Phi1. Intended usage: legacy CSD for balancing over a full csd_sense period (non-overlap should be turned off)" />
        <value name="PHI1" value="1" desc="Comparator is active during Phi1 only. Currently no known use-case." />
        <value name="PHI2" value="10" desc="Comparator is active during Phi2 only. Intended usage: CSD Low EMI." />
        <value name="PHI1_2" value="11" desc="Comparator is activated at the start of both Phi1 and Phi2 (non-overlap should be enabled). Intended usage: CSX, or Full-Wave." />
      </field>
      <field name="CMP_MODE" from="28" to="28" access="RW" resetVal="" desc="Select which signal to output on dsi_sample_out." hidden="false">
        <value name="CSD" value="0" desc="CSD mode: output the filtered sample signal on dsi_sample_out" />
        <value name="GP" value="1" desc="General Purpose mode: output the unfiltered sample unfiltered comparator output, either asynchronous or flopped." />
      </field>
      <field name="FEEDBACK_MODE" from="29" to="29" access="RW" resetVal="" desc="This bit controls whether the output directly from the comparator (csdcmp_out) or the flopped version (csdcmp_out_ff) is used. For CSD operation, the selected signal controls the IDAC(s), in GP mode the signal goes out on dsi_sample_out." hidden="false">
        <value name="FLOP" value="0" desc="Use feedback from sampling flip-flop (used in most modes)." />
        <value name="COMP" value="1" desc="Use feedback from comparator directly (used in single Cmod mutual cap sensing only)" />
      </field>
      <field name="AZ_EN" from="31" to="31" access="RW" resetVal="" desc="Auto-Zero enable, allow the Sequencer to Auto-Zero this component" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_IDACA" address="0x400C01C0" bitWidth="32" desc="IDACA Configuration" hidden="false">
      <field name="VAL" from="6" to="0" access="RW" resetVal="" desc="Current value setting for this IDAC (7 bits)." hidden="false" />
      <field name="POL_DYN" from="7" to="7" access="RW" resetVal="" desc="Polarity is dynamic, this bit does not influence the logic in the SoftIP, it only goes to the HardIP." hidden="false">
        <value name="STATIC" value="0" desc="Static polarity. Polarity is expected to be stable, so to save power this avoids the shunting of the unused polarity, at the expense of response time." />
        <value name="DYNAMIC" value="1" desc="Dynamic polarity. Polarity is expected to change frequently (e.g. invert after every csd_sense phase), so to improve response time this keeps the shunt of the unused polarity on at the expense of power." />
      </field>
      <field name="POLARITY" from="9" to="8" access="RW" resetVal="" desc="Selects the polarity of the IDAC (sensing operation). Normally the actual polarity depends on this bit, optionally mixed with DSI (see DSI_CTRL_EN) and if LEG1_MODE==CSD also mixed with the CSD configuration and operation. However in mutual cap mode with one IDAC (config.mutual_cap=1 &amp; config.csx_dual_idac=0) the polarity of the IDAC is controlled by csd_sense." hidden="false">
        <value name="VSSA_SRC" value="0" desc="Normal: switch between Vssa and Cmod.  For non-CSD application, IDAC will source current." />
        <value name="VDDA_SNK" value="1" desc="Inverted: switch between Vdda and Cmod. For non-CSD application, IDAC will sink current." />
        <value name="SENSE" value="10" desc="The polarity of the IDAC will follow the csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC." />
        <value name="SENSE_INV" value="11" desc="The polarity of the IDAC will follow the inverted csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC." />
      </field>
      <field name="BAL_MODE" from="11" to="10" access="RW" resetVal="" desc="Balancing mode: only applies to legs configured as CSD." hidden="false">
        <value name="FULL" value="0" desc="enabled from start of Phi2 until disabled by CSDCMP. Intended usage: legacy CSD for balancing over a full csd_sense period (non-overlap should be turned off)" />
        <value name="PHI1" value="1" desc="enabled from start of Phi1 and disabled by CSDCMP or at end of Phi1. Enables dual IDAC CSX or Full-Wave, one for sourcing and the other for sinking." />
        <value name="PHI2" value="10" desc="enabled from start of Phi2 and disabled by CSDCMP or at end of Phi2. Intended usage: CSD Low EMI or  dual IDAC CSX or Full-Wave." />
        <value name="PHI1_2" value="11" desc="enabled from start of both Phi1 and Phi2 and disabled by CSDCMP or at end of Phi1 or Phi2 (if non-overlap enabled). Intended usage: single IDAC CSX, or Full-Wave." />
      </field>
      <field name="LEG1_MODE" from="17" to="16" access="RW" resetVal="" desc="Controls the usage mode of LEG1 and the Polarity bit" hidden="false">
        <value name="GP_STATIC" value="0" desc="General Purpose static mode: LEG1 and POLARITY are controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN). No shunting is used, this saves power when off but also any on/off switching will take longer." />
        <value name="GP" value="1" desc="General Purpose dynamic mode: LEG1 and POLARITY are controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled." />
        <value name="CSD_STATIC" value="10" desc="CSD static mode: LEG1 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In those states LEG1 is controlled by LEG1_EN, csd_sense and the CSD configuration. Polarity is controlled by the CSD configuration and operation. In addition leg1 enable and polarity can optionally be mixed with DSI (see DSI_CTRL_EN). No shunting is used, this saves power when off but also any on/off switching will take longer." />
        <value name="CSD" value="11" desc="CSD dynamic mode: LEG1 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In thoses states LEG1 is controlled by LEG1_EN, the CSD configuration, csd_sense and the flopped CSDCMP output (CSDCMP_OUT_FF). Polarity is controlled by the CSD configuration and operation. In addition leg1 enable and polarity can optionally be mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled." />
      </field>
      <field name="LEG2_MODE" from="19" to="18" access="RW" resetVal="" desc="Controls the usage mode of LEG2" hidden="false">
        <value name="GP_STATIC" value="0" desc="General Purpose static mode: LEG2 is controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN).  No shunting is used, this saves power when off but also any on/off switching will take longer." />
        <value name="GP" value="1" desc="General Purpose dynamic mode: LEG2 is controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled." />
        <value name="CSD_STATIC" value="10" desc="CSD static mode: LEG2 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In those states LEG2 is controlled by LEG2_EN, csd_sense and the CSD configuration. Polarity is controlled by the CSD configuration and operation. In addition leg2 enable and polarity can optionally be mixed with DSI (see DSI_CTRL_EN). No shunting is used, this saves power when off but also any on/off switching will take longer." />
        <value name="CSD" value="11" desc="CSD dynamic mode: LEG2 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In those states LEG2 is controlled by LEG2_EN, the CSD configuration, csd_sense and the flopped CSDCMP output (CSDCMP_OUT_FF). In addition leg2 enable can optionally be mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled." />
      </field>
      <field name="DSI_CTRL_EN" from="21" to="21" access="RW" resetVal="" desc="Mix DSI inputs with MMIO controls or not (before getting mixed with CSD controls if enabled).&#xA;0: no DSI control &#xA;     IDACA_POLARITY = IDACA.POLARITY &#xA;     IDACA_LEG1_EN =  IDACA.LEG1_EN &#xA;     IDACA_LEG2_EN = IDACA.LEG2_EN   &#xA;1: Mix MMIO with DSI control&#xA;     IDACA_POLARITY = IDACA.POLARITY EXOR dsi_idaca_pol&#xA;     IDACA_LEG1_EN =  IDACA.LEG1_EN AND dsi_idaca_leg1_en &#xA;     IDACA_LEG2_EN = IDACA.LEG2_EN AND dsi_idaca_leg2_en" hidden="false" />
      <field name="RANGE" from="23" to="22" access="RW" resetVal="" desc="IDAC multiplier" hidden="false">
        <value name="IDAC_LO" value="0" desc="1 LSB =   37.5 nA" />
        <value name="IDAC_MED" value="1" desc="1 LSB =  300 nA" />
        <value name="IDAC_HI" value="10" desc="1 LSB = 2400 nA" />
      </field>
      <field name="LEG1_EN" from="24" to="24" access="RW" resetVal="" desc="output enable for leg 1 to CSDBUSA" hidden="false" />
      <field name="LEG2_EN" from="25" to="25" access="RW" resetVal="" desc="output enable for leg 2 to CSDBUSA" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_IDACB" address="0x400C01C4" bitWidth="32" desc="IDACB Configuration" hidden="false">
      <field name="VAL" from="6" to="0" access="RW" resetVal="" desc="Current value setting for this IDAC (7 bits)." hidden="false" />
      <field name="POL_DYN" from="7" to="7" access="RW" resetVal="" desc="Polarity is dynamic, this bit does not influence the logic in the SoftIP, it only goes to the HardIP." hidden="false">
        <value name="STATIC" value="0" desc="Static polarity. Polarity is expected to be stable, so to save power this avoids the shunting of the unused polarity, at the expense of response time." />
        <value name="DYNAMIC" value="1" desc="Dynamic polarity. Polarity is expected to change frequently (e.g. invert after every csd_sense phase), so to improve response time this keeps the shunt of the unused polarity on at the expense of power." />
      </field>
      <field name="POLARITY" from="9" to="8" access="RW" resetVal="" desc="Selects the polarity of the IDAC (sensing operation). Normally the actual polarity depends on this bit, optionally mixed with DSI (see DSI_CTRL_EN) and if LEG1_EN==1 and LEG1_MODE==CSD also mixed with the CSD configuration and operation. In mutual cap mode however (see config.mutual_cap) the polarity of the IDAC is controlled by csd_sense. If LEG3_EN=1 (the other two legs must be off) then the ADC sequencer controls the IDACB polarity, optionally mixed with DSI." hidden="false">
        <value name="VSSA_SRC" value="0" desc="Normal: switch between Vssa and Cmod.  For non-CSD application, IDAC will source current." />
        <value name="VDDA_SNK" value="1" desc="Inverted: switch between Vdda and Cmod. For non-CSD application, IDAC will sink current." />
        <value name="SENSE" value="10" desc="The polarity of the IDAC will follow the csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC." />
        <value name="SENSE_INV" value="11" desc="The polarity of the IDAC will follow the inverted csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC." />
      </field>
      <field name="BAL_MODE" from="11" to="10" access="RW" resetVal="" desc="same as corresponding IDACA Balancing mode" hidden="false">
        <value name="FULL" value="0" desc="same as corresponding IDACA Balancing mode" />
        <value name="PHI1" value="1" desc="same as corresponding IDACA Balancing mode" />
        <value name="PHI2" value="10" desc="same as corresponding IDACA Balancing mode" />
        <value name="PHI1_2" value="11" desc="same as corresponding IDACA Balancing mode" />
      </field>
      <field name="LEG1_MODE" from="17" to="16" access="RW" resetVal="" desc="Controls the usage mode of LEG1 and the Polarity bit" hidden="false">
        <value name="GP_STATIC" value="0" desc="same as corresponding IDACA.LEG1_MODE" />
        <value name="GP" value="1" desc="same as corresponding IDACA.LEG1_MODE" />
        <value name="CSD_STATIC" value="10" desc="same as corresponding IDACA.LEG1_MODE" />
        <value name="CSD" value="11" desc="same as corresponding IDACA.LEG1_MODE" />
      </field>
      <field name="LEG2_MODE" from="19" to="18" access="RW" resetVal="" desc="Controls the usage mode of LEG2" hidden="false">
        <value name="GP_STATIC" value="0" desc="same as corresponding IDACA.LEG2_MODE" />
        <value name="GP" value="1" desc="same as corresponding IDACA.LEG2_MODE" />
        <value name="CSD_STATIC" value="10" desc="same as corresponding IDACA.LEG2_MODE" />
        <value name="CSD" value="11" desc="same as corresponding IDACA.LEG2_MODE" />
      </field>
      <field name="DSI_CTRL_EN" from="21" to="21" access="RW" resetVal="" desc="Mix DSI inputs with MMIO controls or not (before getting mixed with CSD controls if enabled)&#xA;0: no DSI control&#xA;     IDACB_POLARITY = IDACB.POLARITY &#xA;     IDACB_LEG1_EN =  IDACB.LEG1_EN &#xA;     IDACB_LEG2_EN = IDACB.LEG2_EN   &#xA;     IDACB_LEG3_EN = IDACB.LEG3_EN   &#xA;1: Mix MMIO with DSI control&#xA;     IDACB_POLARITY = IDACB.POLARITY EXOR dsi_idacb_pol&#xA;     IDACB_LEG1_EN =  IDACB.LEG1_EN AND dsi_idacb_leg1_en &#xA;     IDACB_LEG2_EN = IDACB.LEG2_EN AND dsi_idacb_leg2_en  &#xA;     IDACB_LEG3_EN = IDACB.LEG3_EN AND dsi_idacb_leg3_en" hidden="false" />
      <field name="RANGE" from="23" to="22" access="RW" resetVal="" desc="IDAC multiplier" hidden="false">
        <value name="IDAC_LO" value="0" desc="1 LSB =   37.5 nA" />
        <value name="IDAC_MED" value="1" desc="1 LSB =  300 nA" />
        <value name="IDAC_HI" value="10" desc="1 LSB = 2400 nA" />
      </field>
      <field name="LEG1_EN" from="24" to="24" access="RW" resetVal="" desc="output enable for leg 1 to CSDBUSB or CSDBUSA" hidden="false" />
      <field name="LEG2_EN" from="25" to="25" access="RW" resetVal="" desc="output enable for leg 2 to CSDBUSB or CSDBUSA" hidden="false" />
      <field name="LEG3_EN" from="26" to="26" access="RW" resetVal="" desc="output enable for leg3 to CSDBUSC, only allowed when RANGE = IDAC_LO. When this bit is set both other legs should be off.&#xA;Note that leg3 can only be used for ADC mode, not GP mode. Which means that leg3 can only be on when the ADC Sequencer is in the ADC_measure or Calib_measure state. In those states  leg3 is controlled by the ADC configuration and the HSCMP output. In addition this leg3 enable bit can optionally be mixed with DSI (see DSI_CTRL_EN).&#xA;When LEG3_EN=1 also the IDACB polarity is controlled by the ADC sequencer." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SENSE_PERIOD" address="0x400C0200" bitWidth="32" desc="Sense clock period" hidden="false">
      <field name="SENSE_DIV" from="11" to="0" access="RW" resetVal="" desc="The length-1 of the Sense modulation 'clock' period in clk_csd cycles. For regular CSD one sense clock cycle = one conversion (=phi1+phi2) .&#xA;Note this is the base divider, clock dithering may change the actual period length.&#xA;Note that SENSE_DIV must be at least 1 and additionally also allow for one clk_hf of non overlap on both phases, i.e. if clk_csd=clk_hf then SENSE_DIV must be &gt;=3." hidden="false" />
      <field name="LFSR_SIZE" from="18" to="16" access="RW" resetVal="" desc="Selects the number of bits to be used in the LSFR to provide the clock dithering variation on the base period (was PRS in CSDv1). Whenever the LFSR is used (non zero value in this field) the LFSR_CLEAR bit should also be set." hidden="false">
        <value name="OFF" value="0" desc="Don't use clock dithering (=spreadspectrum) (LFSR output value is zero)" />
        <value name="2B" value="1" desc="2-bit LFSR (G(x)=X^2+X+1, period= 3), range [-1, 1]" />
        <value name="3B" value="10" desc="3-bit LFSR (G(x)=X^3+X+1, period= 7), range [-3, 3]" />
        <value name="4B" value="11" desc="4-bit LFSR (G(x)=X^4+X+1, period= 15), range [-7, 7]" />
        <value name="5B" value="100" desc="5-bit LFSR (G(x)=X^5+X^2+1, period= 31), range [-15, 15]" />
        <value name="8B" value="101" desc="8-bit LFSR (G(x)=X^8+X^4+X^3+X^2+1, period= 255)" />
        <value name="12B" value="110" desc="12-bit LFSR (G(x)=X^12+X^9+X^3+X^2+1, period=4095)" />
      </field>
      <field name="LFSR_SCALE" from="23" to="20" access="RW" resetVal="" desc="Shift the LFSR output left by LSFR_SCALE bits before adding to SENSE_DIV. This dithering is disabled when SEL_LSFR_MSB is set.&#xA;The clock divider to be used = (SENSE_DIV+1) + (SEL_LSFR_MSB ? 0 : (LFSR_OUT&lt;&lt;LFSR_SCALE)).&#xA;Note that the clock divider including the dithering term must fit in 12 bits, otherwise the result is undefined." hidden="false" />
      <field name="LFSR_CLEAR" from="24" to="24" access="RW" resetVal="" desc="When set, forces the LFSR to it's initial state (all ones).  This bit is automatically cleared by hardware after the LFSR is cleared, which is at the next clk_csd positive edge. This bit should be set whenever this register is written and the LFSR is used.&#xA;Note that the LFSR will also get reset to all ones during the AutoZero_1/2 states." hidden="false" />
      <field name="SEL_LFSR_MSB" from="25" to="25" access="RW" resetVal="" desc="Use the MSB of configured LSFR size as csd_sense signal. Intended to be used only with bit 8 or 12-bit LFSR size for CSDv1 backward compatibility (PRS). When this bit is set then clock divider dithering is disabled." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SENSE_DUTY" address="0x400C0204" bitWidth="32" desc="Sense clock duty cycle" hidden="false">
      <field name="SENSE_WIDTH" from="11" to="0" access="RW" resetVal="" desc="Defines the length of the first phase of the sense clock in clk_csd cycles. &#xA;A value of 0 disables this feature and the duty cycle of csd_sense will be 50%, which is equal to SENSE_WIDTH = (SENSE_DIV+1)/2, or when clock dithering is used that becomes [(SENSE_DIV+1) + (LFSR_OUT &lt;&lt; LSFR_SCALE)]/2.  At all times it must be assured that the phases are at least 2 clk_csd cycles (1 for non overlap), if this rule is violated the result is undefined." hidden="false" />
      <field name="SENSE_POL" from="16" to="16" access="RW" resetVal="" desc="Polarity of the sense clock&#xA;0 = start with low phase (typical for regular negative transfer CSD)&#xA;1 = start with high phase" hidden="false" />
      <field name="OVERLAP_PHI1" from="18" to="18" access="RW" resetVal="" desc="NonOverlap or not for Phi1 (csd_sense=0).&#xA;0 = Non-overlap for Phi1, the Phi1 signal is  csd_sense inverted except that the signal goes low 1 clk_sample before csd_sense goes high. Intended usage: new low EMI CSD/CSX with static GPIO.&#xA;1 = 'Overlap' (= not non-overlap) for Phi1, the Phi1 signal is  csd_sense inverted. Intended usage: legacy CSD with GPIO switching, the GPIO internal circuit ensures that the switches are non-overlapping." hidden="false" />
      <field name="OVERLAP_PHI2" from="19" to="19" access="RW" resetVal="" desc="Same as OVERLAP_PHI1 but for Phi2 (csd_sense=1)." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SW_HS_P_SEL" address="0x400C0280" bitWidth="32" desc="HSCMP Pos input switch Waveform selection" hidden="false">
      <field name="SW_HMPM" from="0" to="0" access="RW" resetVal="" desc="Set HMPM switch&#xA;0: static open&#xA;1: static closed" hidden="false" />
      <field name="SW_HMPT" from="4" to="4" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_HMPS" from="8" to="8" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_HMMA" from="12" to="12" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_HMMB" from="16" to="16" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_HMCA" from="20" to="20" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_HMCB" from="24" to="24" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_HMRH" from="28" to="28" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SW_HS_N_SEL" address="0x400C0284" bitWidth="32" desc="HSCMP Neg input switch Waveform selection" hidden="false">
      <field name="SW_HCCC" from="16" to="16" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_HCCD" from="20" to="20" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_HCRH" from="26" to="24" access="RW" resetVal="" desc="Select waveform for corresponding switch" hidden="false" />
      <field name="SW_HCRL" from="30" to="28" access="RW" resetVal="" desc="Select waveform for corresponding switch" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SW_SHIELD_SEL" address="0x400C0288" bitWidth="32" desc="Shielding switches Waveform selection" hidden="false">
      <field name="SW_HCAV" from="2" to="0" access="RW" resetVal="" desc="Select waveform for HMPM switch&#xA;0: static open&#xA;1: static closed&#xA;2: phi1&#xA;3: phi2&#xA;4: phi1 &amp; HSCMP&#xA;5: phi2 &amp; HSCMP&#xA;6: HSCMP (ignores phi1/2)&#xA;7: Reserved" hidden="false" />
      <field name="SW_HCAG" from="6" to="4" access="RW" resetVal="" desc="Select waveform for corresponding switch" hidden="false" />
      <field name="SW_HCBV" from="10" to="8" access="RW" resetVal="" desc="Select waveform for corresponding switch. Note that the waveform for this switch follows the csd_shield signal, i.e. phi1 and phi2 are always delayed by 1 clk_hf cycle w.r.t. the csd_sense phases used for all other switches." hidden="false" />
      <field name="SW_HCBG" from="14" to="12" access="RW" resetVal="" desc="Select waveform for corresponding switch. Note that the waveform for this switch follows the csd_shield signal, i.e. phi1 and phi2 are always delayed by 1 clk_hf cycle w.r.t. the csd_sense phases used for all other switches." hidden="false" />
      <field name="SW_HCCV" from="16" to="16" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_HCCG" from="20" to="20" access="RW" resetVal="" desc="Set corresponding switch&#xA;If the ADC is enabled then this switch is directly controlled by the ADC sequencer." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SW_AMUXBUF_SEL" address="0x400C0290" bitWidth="32" desc="Amuxbuffer switches Waveform selection" hidden="false">
      <field name="SW_IRBY" from="4" to="4" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_IRLB" from="8" to="8" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_ICA" from="12" to="12" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_ICB" from="18" to="16" access="RW" resetVal="" desc="Select waveform for corresponding switch" hidden="false" />
      <field name="SW_IRLI" from="20" to="20" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_IRH" from="24" to="24" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_IRL" from="28" to="28" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SW_BYP_SEL" address="0x400C0294" bitWidth="32" desc="AMUXBUS bypass switches Waveform selection" hidden="false">
      <field name="SW_BYA" from="12" to="12" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_BYB" from="16" to="16" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_CBCC" from="20" to="20" access="RW" resetVal="" desc="Set corresponding switch&#xA;If the ADC is enabled then this switch is directly controlled by the ADC sequencer." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SW_CMP_P_SEL" address="0x400C02A0" bitWidth="32" desc="CSDCMP Pos Switch Waveform selection" hidden="false">
      <field name="SW_SFPM" from="2" to="0" access="RW" resetVal="" desc="Select waveform for corresponding switch" hidden="false" />
      <field name="SW_SFPT" from="6" to="4" access="RW" resetVal="" desc="Select waveform for corresponding switch" hidden="false" />
      <field name="SW_SFPS" from="10" to="8" access="RW" resetVal="" desc="Select waveform for corresponding switch" hidden="false" />
      <field name="SW_SFMA" from="12" to="12" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_SFMB" from="16" to="16" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_SFCA" from="20" to="20" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_SFCB" from="24" to="24" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SW_CMP_N_SEL" address="0x400C02A4" bitWidth="32" desc="CSDCMP Neg Switch Waveform selection" hidden="false">
      <field name="SW_SCRH" from="26" to="24" access="RW" resetVal="" desc="Select waveform for corresponding switch" hidden="false" />
      <field name="SW_SCRL" from="30" to="28" access="RW" resetVal="" desc="Select waveform for corresponding switch" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SW_REFGEN_SEL" address="0x400C02A8" bitWidth="32" desc="Reference Generator Switch Waveform selection" hidden="false">
      <field name="SW_IAIB" from="0" to="0" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_IBCB" from="4" to="4" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_SGMB" from="16" to="16" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_SGRE" from="24" to="24" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_SGR" from="28" to="28" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SW_FW_MOD_SEL" address="0x400C02B0" bitWidth="32" desc="Full Wave Cmod Switch Waveform selection" hidden="false">
      <field name="SW_F1PM" from="0" to="0" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_F1MA" from="10" to="8" access="RW" resetVal="" desc="Select waveform for corresponding switch" hidden="false" />
      <field name="SW_F1CA" from="18" to="16" access="RW" resetVal="" desc="Select waveform for corresponding switch" hidden="false" />
      <field name="SW_C1CC" from="20" to="20" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_C1CD" from="24" to="24" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_C1F1" from="28" to="28" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SW_FW_TANK_SEL" address="0x400C02B4" bitWidth="32" desc="Full Wave Csh_tank Switch Waveform selection" hidden="false">
      <field name="SW_F2PT" from="4" to="4" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_F2MA" from="10" to="8" access="RW" resetVal="" desc="Select waveform for corresponding switch" hidden="false" />
      <field name="SW_F2CA" from="14" to="12" access="RW" resetVal="" desc="Select waveform for corresponding switch" hidden="false" />
      <field name="SW_F2CB" from="18" to="16" access="RW" resetVal="" desc="Select waveform for corresponding switch" hidden="false" />
      <field name="SW_C2CC" from="20" to="20" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_C2CD" from="24" to="24" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
      <field name="SW_C2F2" from="28" to="28" access="RW" resetVal="" desc="Set corresponding switch" hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SW_DSI_SEL" address="0x400C02C0" bitWidth="32" desc="DSI output switch control Waveform selection" hidden="false">
      <field name="DSI_CSH_TANK" from="2" to="0" access="RW" resetVal="" desc="Select waveform for dsi_csh_tank signal (called dsi_cap_lo_en in CDSv1). For CSX when DUAL_CAP_EN is set this signal will have the special functionality to go low one clk_hf cycle ahead of the end of the corresponding csd_sense phase (just like for CSDv1), in all other use-cases the functionality is the same as for other switch controls." hidden="false" />
      <field name="DSI_CMOD" from="6" to="4" access="RW" resetVal="" desc="Select waveform for dsi_cmod signal (called dsi_cap_hi_en in CDSv1).  For CSX when DUAL_CAP_EN is set this signal will have the special functionality to go low one clk_hf cycle ahead of the end of the corresponding csd_sense phase (just like for CSDv1), in all other use-cases the functionality is the same as for other switch controls." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SEQ_TIME" address="0x400C0300" bitWidth="32" desc="Sequencer Timing" hidden="false">
      <field name="AZ_TIME" from="7" to="0" access="RW" resetVal="" desc="Define Auto-Zero time in csd_sense cycles -1." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SEQ_INIT_CNT" address="0x400C0310" bitWidth="32" desc="Sequencer Initial conversion and sample counts" hidden="false">
      <field name="CONV_CNT" from="15" to="0" access="RW" resetVal="" desc="Number of conversion per sample (PERIOD in CSDv1), if set to 0 the Sample_init state will be skipped." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_SEQ_NORM_CNT" address="0x400C0314" bitWidth="32" desc="Sequencer Normal conversion and sample counts" hidden="false">
      <field name="CONV_CNT" from="15" to="0" access="RW" resetVal="" desc="Number of conversion per sample (PERIOD in CSDv1), if set to 0 the Sample_norm state will be skipped." hidden="false" />
    </register>
    <register name="GROUP_CSDV2_ADC_CTL" address="0x400C0320" bitWidth="32" desc="ADC Control" hidden="false">
      <field name="ADC_TIME" from="7" to="0" access="RW" resetVal="" desc="ADC timing -1 in csd_sense clock cycles (actual time is ADC_TIME+1 cycles), either used to discharge Cref1&amp;2, or as the aperture to capture the input voltage on Cref1&amp;2" hidden="false" />
      <field name="ADC_MODE" from="17" to="16" access="RW" resetVal="" desc="Enable ADC measurement. When enabled the ADC sequencer will be started when the main sequencer goes to the SAMPLE_NORM state" hidden="false">
        <value name="OFF" value="0" desc="No ADC measurement" />
        <value name="VREF_CNT" value="1" desc="Count time A to bring Cref1 + Cref2 up from Vssa to Vrefhi with IDACB" />
        <value name="VREF_BY2_CNT" value="10" desc="Count time B to bring Cref1 + Cref2 back up to Vrefhi with IDACB (after bringing them down for time A/2 cycles with IDACB sinking)" />
        <value name="VIN_CNT" value="11" desc="Determine HSCMP polarity and count time C to source/sink Cref1 + Cref2 from Vin to Vrefhi." />
      </field>
    </register>
    <register name="GROUP_CSDV2_SEQ_START" address="0x400C0340" bitWidth="32" desc="Sequencer start" hidden="false">
      <field name="START" from="0" to="0" access="RW" resetVal="" desc="Start the CSD sequencer. The sequencer will clear this bit when it is done. Depending on the mode the sequencer is done when a sample has been accumulated, when the high speed comparator trips or if the sequencer is aborted. When the ADC is enabled the ADC sequencer will start when the CSD sequencer reaches the Sample_norm state (only with the regular CSD scan mode)." hidden="false" />
      <field name="SEQ_MODE" from="1" to="1" access="RW" resetVal="" desc="0 = regular CSD scan + optional ADC &#xA;1 = coarse initialization, the Sequencer will go to the INIT_COARSE state." hidden="false" />
      <field name="ABORT" from="3" to="3" access="RW" resetVal="" desc="When a 1 is written the CSD and ADC sequencers will be aborted (if they are running) and the START bit will be cleared. This bit always read as 0." hidden="false" />
      <field name="DSI_START_EN" from="4" to="4" access="RW" resetVal="" desc="When this bit is set a positive edge on dsi_start will start the CSD sequencer and if enabled also the ADC sequencer." hidden="false" />
      <field name="AZ0_SKIP" from="8" to="8" access="RW" resetVal="" desc="When set the AutoZero_0 state will be skipped" hidden="false" />
      <field name="AZ1_SKIP" from="9" to="9" access="RW" resetVal="" desc="When set the AutoZero_1 state will be skipped" hidden="false" />
    </register>
  </block>
  <block name="D_6" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="R_10" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="VDAC" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false">
    <block name="VDAC_UAB" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false">
      <block name="halfuab" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
      <register name="UAB_UAB_CTRL" address="0x40340000" bitWidth="32" desc="Global UAB control" hidden="false">
        <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="- 0: UAB IP disabled (put analog in power down, open all switches)&#xA;- 1: UAB IP enabled" hidden="false" />
      </register>
      <register name="UAB_INTR" address="0x40340020" bitWidth="32" desc="Interrupt request register" hidden="false">
        <field name="COMP0" from="0" to="0" access="RW" resetVal="" desc="Comparator 0 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit." hidden="false" />
        <field name="VDAC0_EMPTY" from="1" to="1" access="RW" resetVal="" desc="VDAC 0 Interrupt: hardware sets this interrupt when VDAC 0 next value field is empty. Write with '1' to clear bit." hidden="false" />
        <field name="DC0_RES" from="2" to="2" access="RW" resetVal="" desc="Decimator 0 Result Interrupt: hardware sets this interrupt when Decimator 0 writes a new result value in DC0_RES register. Write with '1' to clear bit." hidden="false" />
        <field name="COMP1" from="16" to="16" access="RW" resetVal="" desc="Comparator 1 Interrupt: hardware sets this interrupt when comparator 1 triggers. Write with '1' to clear bit." hidden="false" />
        <field name="VDAC1_EMPTY" from="17" to="17" access="RW" resetVal="" desc="VDAC 1 Interrupt: hardware sets this interrupt when VDAC 1 next value field is empty. Write with '1' to clear bit." hidden="false" />
        <field name="DC1_RES" from="18" to="18" access="RW" resetVal="" desc="Decimator 1 Result Interrupt: hardware sets this interrupt when Decimator 1 writes a new result value in DC1_RES register. Write with '1' to clear bit." hidden="false" />
      </register>
      <register name="UAB_INTR_SET" address="0x40340024" bitWidth="32" desc="Interrupt request set register" hidden="false">
        <field name="COMP0_SET" from="0" to="0" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
        <field name="VDAC0_EMPTY_SET" from="1" to="1" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
        <field name="DC0_RES_SET" from="2" to="2" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
        <field name="COMP1_SET" from="16" to="16" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
        <field name="VDAC1_EMPTY_SET" from="17" to="17" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
        <field name="DC1_RES_SET" from="18" to="18" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      </register>
      <register name="UAB_INTR_MASK" address="0x40340028" bitWidth="32" desc="Interrupt request mask" hidden="false">
        <field name="COMP0_MASK" from="0" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
        <field name="VDAC0_EMPTY_MASK" from="1" to="1" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
        <field name="DC0_RES_MASK" from="2" to="2" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
        <field name="COMP1_MASK" from="16" to="16" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
        <field name="VDAC1_EMPTY_MASK" from="17" to="17" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
        <field name="DC1_RES_MASK" from="18" to="18" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      </register>
      <register name="UAB_INTR_MASKED" address="0x4034002C" bitWidth="32" desc="Interrupt request masked" hidden="false">
        <field name="COMP0_MASKED" from="0" to="0" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
        <field name="VDAC0_EMPTY_MASKED" from="1" to="1" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
        <field name="DC0_RES_MASKED" from="2" to="2" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
        <field name="COMP1_MASKED" from="16" to="16" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
        <field name="VDAC1_EMPTY_MASKED" from="17" to="17" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
        <field name="DC1_RES_MASKED" from="18" to="18" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      </register>
      <register name="UAB_OA0_CTRL" address="0x40340200" bitWidth="32" desc="Opamp, comparator, buffer  controls" hidden="false">
        <field name="OA0_PWR" from="2" to="0" access="RW" resetVal="" desc="Opamp0 power level" hidden="false" />
        <field name="CMP0_PWR" from="10" to="8" access="RW" resetVal="" desc="Comparator0 power level" hidden="false" />
        <field name="CMP0_EDGE" from="13" to="12" access="RW" resetVal="" desc="Comparator0 edge detect for interrupt and trigger" hidden="false">
          <value name="DISABLE" value="0" desc="Disabled, no interrupts will be detected" />
          <value name="RISING" value="1" desc="Rising edge" />
          <value name="FALLING" value="10" desc="Falling edge" />
          <value name="BOTH" value="11" desc="Both rising and falling edges" />
        </field>
        <field name="CMP0_DSI_LEVEL" from="14" to="14" access="RW" resetVal="" desc="Comparator0 trigger out level : 0=pulse, 1=level" hidden="false" />
        <field name="CTRL0_SPARE" from="15" to="15" access="RW" resetVal="" desc="Spare bit" hidden="false" />
        <field name="REF0_PWR" from="18" to="16" access="RW" resetVal="" desc="Reference0 buffer power level" hidden="false" />
        <field name="REF0_PTS" from="19" to="19" access="RW" resetVal="" desc="1- Pull the Reference0 buffer output to VDDA" hidden="false" />
        <field name="AGND0_PWR" from="22" to="20" access="RW" resetVal="" desc="Agnd0 buffer power level" hidden="false" />
        <field name="AGND0_PTS" from="23" to="23" access="RW" resetVal="" desc="1 - Pull Agnd0 buffer output to VDDA" hidden="false" />
        <field name="SW_GG" from="24" to="24" access="RW" resetVal="" desc="Connect outputs of Agnd0 and Agnd1 buffer, one buffer must be off.&#xA;This is to drive both UAB halves with the same buffer, so both halves get the same offset noise." hidden="false" />
        <field name="SPARE0_EN" from="25" to="25" access="RW" resetVal="" desc="1 - Enable spare reference" hidden="false" />
        <field name="H0_PWR" from="31" to="30" access="RW" resetVal="" desc="UAB Half, power profile" hidden="false">
          <value name="NORMAL" value="0" desc="Normal, for normal analog clock speeds" />
          <value name="ULTRA_LOW" value="1" desc="Ultra low power, only allowed for lower analog clock speeds" />
          <value name="ULTRA_HIGH" value="10" desc="Ultra high performance, for higher analog clock speeds (also ultra high power)" />
          <value name="Reserved" value="11" desc="Reserved, do not use" />
        </field>
      </register>
      <register name="UAB_CAP_CTRL0" address="0x40340204" bitWidth="32" desc="Capacitance controls" hidden="false">
        <field name="CB0_GND" from="5" to="5" access="RW" resetVal="" desc="Ground unused caps of CB0 array&#xA;0: leave unused caps floating&#xA;1: ground unused caps (typical when attentuation Cap is used, e.g. for VDAC use-case)" hidden="false" />
        <field name="CC0_GND" from="6" to="6" access="RW" resetVal="" desc="Ground unused caps of CC0 array&#xA;0: leave unused caps floating&#xA;1: ground unused caps (typical when attentuation Cap is used)" hidden="false" />
        <field name="FRC0_SIGN_BIT" from="28" to="28" access="RW" resetVal="" desc="Forces the sign bit to be 1 in DAC mode.  This is used to achieve &#xA;0 - AGND0 range for unsigned numbers using DAC mode 2" hidden="false" />
        <field name="DAC0_MODE_EN" from="29" to="29" access="RW" resetVal="" desc="0: SIGN0_VAL can be programmed to be a modbit source&#xA;1: SIGN0_VAL is a dedicated sign bit (FW modbit source tied to 0)" hidden="false" />
        <field name="DAC0_MODE" from="31" to="30" access="RW" resetVal="" desc="DAC mode, this determines the AB Cap Value decoding" hidden="false">
          <value name="UNSIGNED12" value="0" desc="Off or Unsigned 12-bit VDAC, i.e. no AB Cap value decoding.&#xA;SIGN1_VAL can be used as Firmware controlled modbit (e.g. to invert the Voltage for a Sign + Magnitude VDAC)" />
          <value name="VIRT_SIGNED12" value="1" desc="Virtual signed 12-bits' VDAC. AB Cap value decoding: &#xA;add 0x800 to the 12-bit AB Cap Value (=invert MSB), to convert the lowest signed number 0x800 to the lowest unsigned number 0x000. This is the same as the SAR handles 12-bit 'virtual' signed numbers." />
          <value name="SIGNED13" value="10" desc="Signed 13-bit twos complement. AB Cap value decoding: &#xA;for negative values (SIGN0_VAL=1) the AB Cap values are inverted, the 64th B cap unit is enabled and the Voltage should be inverted.&#xA;- Voltage inversion only works if the right clocking waveforms, switch settings and reference voltages are used.&#xA;- Enabling the 64th B cap unit adds 1 so that only a AB Cap value inversion is needed to create a true twos complement." />
          <value name="RESERVED" value="11" desc="" />
        </field>
      </register>
      <register name="UAB_CAP_ABCF0_VAL" address="0x40340208" bitWidth="32" desc="Capacitance values for CA0, CB0, CC0 and CF0" hidden="false">
        <field name="CB0_VAL" from="5" to="0" access="RW" resetVal="" desc="Cap B0 Value, in DAC_MODE 1 and 2 this value is decoded" hidden="false" />
        <field name="CA0_VAL" from="11" to="6" access="RW" resetVal="" desc="Cap A0 Value, in DAC_MODE 1 and 2 this value is decoded" hidden="false" />
        <field name="SIGN0_VAL" from="12" to="12" access="RW" resetVal="" desc="Sign bit Value, when used in DAC_MODE, otherwise Firmware modbit.&#xA;In DAC_MODE the modbit should be used to invert the voltage on the AB Caps for the negative DAC values." hidden="false" />
        <field name="CB0_64" from="13" to="13" access="RW" resetVal="" desc="Enable 64th Cap of CB0 array.  In DAC mode the FW setting is overridden by the hardware based on DAC_MODE setting.&#xA;1 - Enables the 64th cap.  This will also set CB0_val[5:0] to be 6'h3F" hidden="false" />
        <field name="CC0_VAL" from="21" to="16" access="RW" resetVal="" desc="Cap C0 Value" hidden="false" />
        <field name="CF0_VAL" from="28" to="24" access="RW" resetVal="" desc="Cap F0 Value [2..64 is the range in steps of 2]" hidden="false" />
      </register>
      <register name="UAB_CAP_AB0_VAL_NXT" address="0x4034020C" bitWidth="32" desc="Next capacitance values for CA0 and CB0" hidden="false">
        <field name="CB0_VAL" from="5" to="0" access="RW" resetVal="" desc="Cap B0 Value" hidden="false" />
        <field name="CA0_VAL" from="11" to="6" access="RW" resetVal="" desc="Cap A0 Value" hidden="false" />
        <field name="SIGN0_VAL" from="12" to="12" access="RW" resetVal="" desc="Sign bit Value" hidden="false" />
      </register>
      <register name="UAB_CAP_CF0_VAL_NXT" address="0x40340210" bitWidth="32" desc="Next capacitance values for CC0 and CF0" hidden="false">
        <field name="CC0_VAL" from="21" to="16" access="RW" resetVal="" desc="Cap C0 Value" hidden="false" />
        <field name="CF0_VAL" from="28" to="24" access="RW" resetVal="" desc="Cap F0 Value" hidden="false" />
        <field name="CC0_VAL_UPDATE" from="30" to="30" access="RW" resetVal="" desc="1 - Update the CC0 cap value with CAP_CC0_VAL_NXT.CC0_VAL" hidden="false" />
        <field name="CF0_VAL_UPDATE" from="31" to="31" access="RW" resetVal="" desc="1 - Update the CF0 cap value with CAP_CF0_VAL_NXT.CF0_VAL" hidden="false" />
      </register>
      <register name="UAB_STARTUP_DELAY0" address="0x40340220" bitWidth="32" desc="Startup delay" hidden="false">
        <field name="STARTUP_DELAY" from="15" to="0" access="RW" resetVal="" desc="Startup delay to synchronize the UAB-SAR interface. The usage and meaning of this field depends on the value of the ALIGN_MODE bit (below).   A value of 0 disables this function." hidden="false" />
        <field name="ALIGN_MODE" from="16" to="16" access="RW" resetVal="" desc="0 - STARTUP_DELAY is number of clk_hf clocks to delay the UAB clock after a SAR Trigger for UAB-SAR alignment in scheduled mode&#xA;1 - STARTUP_DELAY is number of clk_hf clocks to delay UAB trigger to SAR for UAB-SAR alignment in unscheduled mode" hidden="false" />
      </register>
      <register name="UAB_SUBSAMPLE_CTRL0" address="0x40340224" bitWidth="32" desc="Subsample control" hidden="false">
        <field name="SUBSAMPLE" from="7" to="0" access="RW" resetVal="" desc="Subsampling: suppress Valid output during the first SUBSAMPLE analog clock periods. Only allow Valid output in the last of the SUBSAMPLE+1 analog clock periods.&#xA;A value of 0 will not suppress Valid output." hidden="false" />
        <field name="SUBSAMPLE_INIT" from="15" to="8" access="RW" resetVal="" desc="Initial value of the subsampling down counter. Before this UAB half is running the firmware can write to this field the initial value of the subsample down counter. It is recommend that the following is true for the initial value  SUBSAMPLE_INIT&lt;=SUBSAMPLE, however this is not a requirement. Writing a bigger value can be used to postpone the very first Valid output." hidden="false" />
      </register>
      <register name="UAB_SW_STATIC0" address="0x40340230" bitWidth="32" desc="Static switches for half 0 of the UAB" hidden="false">
        <field name="SW_G00" from="0" to="0" access="RW" resetVal="" desc="VIN00 to OA0.vplus (AG0)" hidden="false" />
        <field name="SW_G01" from="1" to="1" access="RW" resetVal="" desc="VIN01 to OA0.vplus (AG0)" hidden="false" />
        <field name="SW_G02" from="2" to="2" access="RW" resetVal="" desc="VIN02 to OA0.vplus (AG0)" hidden="false" />
        <field name="SW_G03" from="3" to="3" access="RW" resetVal="" desc="VIN03 to OA0.vplus (AG0)" hidden="false" />
        <field name="SW_R0G" from="4" to="4" access="RW" resetVal="" desc="REF0 to OA0.vplus (AG0)" hidden="false" />
        <field name="SW_G0G" from="5" to="5" access="RW" resetVal="" desc="AGND0 to OA0.vplus (AG0)" hidden="false" />
        <field name="SW_R0T" from="8" to="8" access="RW" resetVal="" desc="REF0 to cmp0.vminus (Threshold)" hidden="false" />
        <field name="SW_G0T" from="9" to="9" access="RW" resetVal="" desc="AGND0 to cmp0.vminus (Threshold)" hidden="false" />
        <field name="SW_Q0T" from="10" to="10" access="RW" resetVal="" desc="OUT1 to cmp0.vminus (Threshold)" hidden="false" />
        <field name="EARLY_P0S" from="12" to="12" access="RW" resetVal="" desc="OUT0 to Sum0 switch timing: 0=Regular, 1=Early" hidden="false" />
        <field name="EARLY_P0O" from="13" to="13" access="RW" resetVal="" desc="OUT0 to VOUT0 switch timing: 0=Regular, 1=Early" hidden="false" />
        <field name="RMB0_BITS" from="19" to="16" access="RW" resetVal="" desc="Risk mitigation bits (To be defined if they are used)" hidden="false" />
        <field name="STRB_RST0_SEL" from="28" to="24" access="RW" resetVal="" desc="Select source either for VDAC strobe or analog-reset to discharge all Caps (Delsig Modulator use-case)&#xA;0 = Decimator0 half 0 analog-reset output&#xA;1 = Decimator0 half 1 analog-reset output&#xA;2 = Decimator1 half 0 analog-reset output&#xA;3 = Decimator1 half 1 analog-reset output&#xA;4 = Decimator2 half 0 analog-reset output&#xA;5 = Decimator2 half 1 analog-reset output&#xA;6 = Decimator3 half 0 analog-reset output&#xA;7 = Decimator3 half 1 analog-reset output&#xA;8-31 = generic trigger input 0-23&#xA;For PASS4B  only values 0-1 and 8-13 are legal." hidden="false" />
        <field name="STRB_RST0_EN" from="29" to="29" access="RW" resetVal="" desc="Enable VDAC strobe or UAB analog-reset:&#xA;0: Use selected source as VDAC strobe for next CA0 and CB0 values&#xA;1: Use selected source as Analog-reset (discharge all Caps)" hidden="false" />
      </register>
      <register name="UAB_SW_MODBIT_SRC0" address="0x40340234" bitWidth="32" desc="Select source of Modbit for A,B and C branches of half 0" hidden="false">
        <field name="MODBIT0_SRC0_SEL" from="4" to="0" access="RW" resetVal="" desc="Select source of modbit for A &amp; B branches&#xA;0=UAB0 half 0 comparator output&#xA;1=UAB0 half 1 comparator output&#xA;2=UAB1 half 0 comparator output&#xA;3=UAB1 half 1 comparator output&#xA;4=UAB2 half 0 comparator output&#xA;5=UAB2 half 1 comparator output&#xA;6=UAB3 half 0 comparator output&#xA;7=UAB3 half 1 comparator output&#xA;8-30 = generic trigger inputs 0-22&#xA;31=SIGN0_VAL, also used as Firmware modbit. &#xA;For PASS4B  only values 0-1 and 8-13 and 31 are legal." hidden="false" />
        <field name="MODBIT1_SRC0_SEL" from="12" to="8" access="RW" resetVal="" desc="Select source of modbit for C branch&#xA;0=UAB0 half 0 comparator output&#xA;1=UAB0 half 1 comparator output&#xA;2=UAB1 half 0 comparator output&#xA;3=UAB1 half 1 comparator output&#xA;4=UAB2 half 0 comparator output&#xA;5=UAB2 half 1 comparator output&#xA;6=UAB3 half 0 comparator output&#xA;7=UAB3 half 1 comparator output&#xA;8-30 = generic trigger inputs 0-22&#xA;31=SIGN0_VAL, also used as Firmware modbit. &#xA;For PASS4B  only values 0-1 and 8-13 and 31 are legal." hidden="false" />
      </register>
      <register name="UAB_SW_CA0_IN0" address="0x40340240" bitWidth="32" desc="Cap A0 input switches set 0" hidden="false">
        <field name="SW_A00_CMP" from="3" to="0" access="RW" resetVal="" desc="VIN00 to Cap A0 input, allows for modbit control" hidden="false" />
        <field name="SW_A01_CMP" from="7" to="4" access="RW" resetVal="" desc="VIN01 to Cap A0 input, allows for modbit control" hidden="false" />
        <field name="SW_A02_CMP" from="11" to="8" access="RW" resetVal="" desc="VIN02 to Cap A0 input, allows for modbit control" hidden="false" />
        <field name="SW_A03_CMP" from="15" to="12" access="RW" resetVal="" desc="VIN03 to Cap A0 input, allows for modbit control" hidden="false" />
        <field name="SW_A0P" from="19" to="16" access="RW" resetVal="" desc="OUT0 to Cap A0 input" hidden="false" />
        <field name="SW_A0Q" from="23" to="20" access="RW" resetVal="" desc="OUT1 to Cap A0 input" hidden="false" />
      </register>
      <register name="UAB_SW_CA0_IN1" address="0x40340244" bitWidth="32" desc="Cap A0 input switches set 1" hidden="false">
        <field name="SW_AA" from="3" to="0" access="RW" resetVal="" desc="Cap A0 input to Cap A1 input&#xA;(Note: In the UAB design this is the called AM switch)" hidden="false" />
        <field name="SW_A0R_CMP" from="7" to="4" access="RW" resetVal="" desc="REF0 to Cap A0 input, allows for modbit control" hidden="false" />
        <field name="SW_A0G_CMP" from="11" to="8" access="RW" resetVal="" desc="AGND0 to Cap A0 input, allows for modbit control" hidden="false" />
        <field name="SW_A0V_CMP" from="15" to="12" access="RW" resetVal="" desc="VSS to Cap A0 input, allows for modbit control" hidden="false" />
      </register>
      <register name="UAB_SW_CA0_TOP" address="0x40340248" bitWidth="32" desc="Cap A0 top plate switches" hidden="false">
        <field name="SW_R0A_CMP" from="3" to="0" access="RW" resetVal="" desc="Cap A0 top plate to REF0, allows for modbit control" hidden="false" />
        <field name="SW_G0A_CMP" from="7" to="4" access="RW" resetVal="" desc="Cap A0 top plate to AGND0, allows for modbit control" hidden="false" />
        <field name="SW_V0A_CMP" from="11" to="8" access="RW" resetVal="" desc="Cap A0 top plate to VSS, allows for modbit control" hidden="false" />
        <field name="SW_S0A" from="19" to="16" access="RW" resetVal="" desc="Cap A0 top plate to SUM0" hidden="false" />
      </register>
      <register name="UAB_SW_CB0_IN0" address="0x40340250" bitWidth="32" desc="Cap B0 input switches set 0" hidden="false">
        <field name="SW_B00_CMP" from="3" to="0" access="RW" resetVal="" desc="VIN00 to Cap B0 input, allows for modbit control" hidden="false" />
        <field name="SW_B01_CMP" from="7" to="4" access="RW" resetVal="" desc="VIN01 to Cap B0 input, allows for modbit control" hidden="false" />
        <field name="SW_B02_CMP" from="11" to="8" access="RW" resetVal="" desc="VIN02 to Cap B0 input, allows for modbit control" hidden="false" />
        <field name="SW_B03_CMP" from="15" to="12" access="RW" resetVal="" desc="VIN03 to Cap B0 input, allows for modbit control" hidden="false" />
        <field name="SW_B0P" from="19" to="16" access="RW" resetVal="" desc="OUT0 to Cap B0 input" hidden="false" />
        <field name="SW_B0Q" from="23" to="20" access="RW" resetVal="" desc="OUT1 to Cap B0 input" hidden="false" />
      </register>
      <register name="UAB_SW_CB0_IN1" address="0x40340254" bitWidth="32" desc="Cap B0 input switches set 1" hidden="false">
        <field name="SW_BB" from="3" to="0" access="RW" resetVal="" desc="Cap B0 input to Cap B1 input&#xA;(Note: In the UAB design this is called the BM switch)" hidden="false" />
        <field name="SW_B0R_CMP" from="7" to="4" access="RW" resetVal="" desc="REF0 to Cap B0 input, allows for modbit control" hidden="false" />
        <field name="SW_B0G_CMP" from="11" to="8" access="RW" resetVal="" desc="AGND0 to Cap B0 input, allows for modbit control" hidden="false" />
        <field name="SW_B0V_CMP" from="15" to="12" access="RW" resetVal="" desc="VSS to Cap B0 input, allows for modbit control" hidden="false" />
      </register>
      <register name="UAB_SW_CB0_TOP" address="0x40340258" bitWidth="32" desc="Cap A0 top plate switches" hidden="false">
        <field name="SW_R0B_CMP" from="3" to="0" access="RW" resetVal="" desc="Cap B0 top plate to REF0, allows for modbit control" hidden="false" />
        <field name="SW_G0B_CMP" from="7" to="4" access="RW" resetVal="" desc="Cap B0 top plate to AGND0, allows for modbit control" hidden="false" />
        <field name="SW_V0B_CMP" from="11" to="8" access="RW" resetVal="" desc="Cap B0 top plate to VSS, allows for modbit control" hidden="false" />
        <field name="SW_T0B" from="15" to="12" access="RW" resetVal="" desc="Cap B0 top plate Trim/Attenuation bypass" hidden="false" />
        <field name="SW_S0B" from="19" to="16" access="RW" resetVal="" desc="Cap B0 top plate to SUM0" hidden="false" />
      </register>
      <register name="UAB_SW_CC0_IN0" address="0x40340260" bitWidth="32" desc="Cap C0 input switches set 0" hidden="false">
        <field name="SW_C00_CMP" from="3" to="0" access="RW" resetVal="" desc="VIN00 to Cap C0 input, allows for modbit control" hidden="false" />
        <field name="SW_C01_CMP" from="7" to="4" access="RW" resetVal="" desc="VIN01 to Cap C0 input, allows for modbit control" hidden="false" />
        <field name="SW_C02_CMP" from="11" to="8" access="RW" resetVal="" desc="VIN02 to Cap C0 input, allows for modbit control" hidden="false" />
        <field name="SW_C03_CMP" from="15" to="12" access="RW" resetVal="" desc="VIN03 to Cap C0 input, allows for modbit control" hidden="false" />
        <field name="SW_C0P" from="19" to="16" access="RW" resetVal="" desc="OUT0 to Cap C0 input" hidden="false" />
        <field name="SW_C0Q" from="23" to="20" access="RW" resetVal="" desc="OUT1 to Cap C0 input" hidden="false" />
      </register>
      <register name="UAB_SW_CC0_IN1" address="0x40340264" bitWidth="32" desc="Cap C0 input switches set 1" hidden="false">
        <field name="SW_CC" from="3" to="0" access="RW" resetVal="" desc="Cap C0 input to Cap C1 input&#xA;(Note: In the UAB design this is called the CM switch)" hidden="false" />
        <field name="SW_C0R_CMP" from="7" to="4" access="RW" resetVal="" desc="REF0 to Cap C0 input, allows for modbit control" hidden="false" />
        <field name="SW_C0G_CMP" from="11" to="8" access="RW" resetVal="" desc="AGND0 to Cap C0 input, allows for modbit control" hidden="false" />
        <field name="SW_C0V_CMP" from="15" to="12" access="RW" resetVal="" desc="VSS to Cap C0 input, allows for modbit control" hidden="false" />
      </register>
      <register name="UAB_SW_CC0_TOP" address="0x40340268" bitWidth="32" desc="Cap A0 top plate switches" hidden="false">
        <field name="SW_R0C_CMP" from="3" to="0" access="RW" resetVal="" desc="Cap C0 top plate to REF0, allows for modbit control" hidden="false" />
        <field name="SW_G0C_CMP" from="7" to="4" access="RW" resetVal="" desc="Cap C0 top plate to AGND0, allows for modbit control" hidden="false" />
        <field name="SW_V0C_CMP" from="11" to="8" access="RW" resetVal="" desc="Cap C0 top plate to VSS, allows for modbit control" hidden="false" />
        <field name="SW_T0C" from="15" to="12" access="RW" resetVal="" desc="Cap C0 top plate Trim/Attenuation bypass" hidden="false" />
        <field name="SW_S0C" from="19" to="16" access="RW" resetVal="" desc="Cap C0 top plate to SUM0" hidden="false" />
        <field name="SW_S10" from="23" to="20" access="RW" resetVal="" desc="Cap C0 top plate to SUM1" hidden="false" />
      </register>
      <register name="UAB_SW_CF0_BOT" address="0x4034026C" bitWidth="32" desc="Cap F0 bottom plate and output switches" hidden="false">
        <field name="SW_G0F" from="3" to="0" access="RW" resetVal="" desc="Cap F0 bottom plate to AGND0" hidden="false" />
        <field name="SW_P0F" from="7" to="4" access="RW" resetVal="" desc="Cap F0 bottom plate to OUT0" hidden="false" />
        <field name="SW_P0S" from="11" to="8" access="RW" resetVal="" desc="Cap F bypass, OUT0 to SUM0" hidden="false" />
        <field name="SW_P0O" from="15" to="12" access="RW" resetVal="" desc="OUT0 to VOUT0" hidden="false" />
      </register>
      <register name="UAB_SW_OTHER0" address="0x40340270" bitWidth="32" desc="Other clocked controls" hidden="false">
        <field name="CMP0_FF" from="3" to="0" access="RW" resetVal="" desc="Clock for Flip-Flop after Comparator 0" hidden="false" />
        <field name="VALID0" from="7" to="4" access="RW" resetVal="" desc="Valid0, output flag to indicated that VOUT0 is valid. The Valid output can be suppressed due to sub-sampling. Note that when sub-sampling is used this clocking waveform is used to decrement the counter (decrement is aligned with the positive edge of this clocking waveform)." hidden="false" />
        <field name="TRIG0_OUT" from="11" to="8" access="RW" resetVal="" desc="Trigger output (for other UABs or SAR)" hidden="false" />
        <field name="STROBE_SW0" from="27" to="24" access="RW" resetVal="" desc="Strobe for dsi_sw_ctrl (modbit) update, dsi_sw_ctrl updates in sync with posedge of this wave. To disable set to 0. To enable update anytime use 15." hidden="false" />
        <field name="STROBE_RST0" from="31" to="28" access="RW" resetVal="" desc="Use the positive edge of the selected clocking waveform to synchronize: &#xA; STRB_RST0_EN=0: Capacitor Value update (Capacitor Strobe)&#xA; STRB_RST0_EN=1: UAB analog-reset update&#xA;Set to 0 to disable both functions. Result undefined for value 15." hidden="false" />
      </register>
      <register name="UAB_SW_BOOST_CTRL0" address="0x40340274" bitWidth="32" desc="Bootstrap clock control" hidden="false">
        <field name="CA0_BOOST" from="3" to="0" access="RW" resetVal="" desc="Clock for boot strap master in A branch" hidden="false" />
        <field name="CB0_BOOST" from="7" to="4" access="RW" resetVal="" desc="Clock for boot strap master in B branch" hidden="false" />
        <field name="CC0_BOOST" from="11" to="8" access="RW" resetVal="" desc="Clock for boot strap master in C branch" hidden="false" />
        <field name="CF0_BOOST" from="15" to="12" access="RW" resetVal="" desc="Clock for boot strap master in F branch" hidden="false" />
        <field name="SUM0_BOOST" from="19" to="16" access="RW" resetVal="" desc="Clock for boot strap master in Summing node branch" hidden="false" />
        <field name="PUMP0_WAVE" from="23" to="20" access="RW" resetVal="" desc="Clock for pump in half0" hidden="false" />
      </register>
      <register name="UAB_SRAM0_CTRL" address="0x40340278" bitWidth="32" desc="SRAM programmed size" hidden="false">
        <field name="LAST_STEP" from="3" to="0" access="RW" resetVal="" desc="Last step of wave programmed in the SRAM" hidden="false" />
        <field name="TRIG_SEL0" from="28" to="24" access="RW" resetVal="" desc="input Trigger select&#xA;0=UAB0 half 0 trigger output&#xA;1=UAB0 half 1 trigger output&#xA;2=UAB1 half 0 trigger output&#xA;3=UAB1 half 1 trigger output&#xA;4=UAB2 half 0 trigger output&#xA;5=UAB2 half 1 trigger output&#xA;6=UAB3 half 0 trigger output&#xA;7=UAB3 half 1 trigger output&#xA;8-30 = generic trigger inputs 0-22&#xA;31=SAR trigger output&#xA;For PASS4B  only values 0-1 and 8-13 and 31 are legal." hidden="false" />
        <field name="TRIGGER_EN" from="29" to="29" access="RW" resetVal="" desc="Enable input trigger:&#xA;0: Ignore triggers, start running immediately after setting RUN bit&#xA;1: After RUN bit is set wait for a positive edge on the selected trigger input" hidden="false" />
        <field name="RUN" from="31" to="31" access="RW" resetVal="" desc="Set to start executing the waveform (may need to wait for a trigger). Clear to stop this UAB half. When RUN=0 all dynamic switches are forced open." hidden="false" />
      </register>
      <register name="UAB_STAT0" address="0x4034027C" bitWidth="32" desc="Status Current SRAM counter and comparator" hidden="false">
        <field name="CURR_STEP" from="3" to="0" access="R" resetVal="" desc="Current step executed from the SRAM" hidden="false" />
        <field name="COMP" from="4" to="4" access="R" resetVal="" desc="Current comparator status" hidden="false" />
        <field name="CURR_SUBSAMPLE" from="31" to="24" access="R" resetVal="" desc="Current value of the subsampling down counter. The Valid is suppressed when SUBSAMPLE_CUR!=0." hidden="false" />
      </register>
      <register name="UAB_SRAM00" address="0x40340280" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM01" address="0x40340284" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM02" address="0x40340288" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM03" address="0x4034028C" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM04" address="0x40340290" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM05" address="0x40340294" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM06" address="0x40340298" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM07" address="0x4034029C" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM08" address="0x403402A0" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM09" address="0x403402A4" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM010" address="0x403402A8" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM011" address="0x403402AC" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM012" address="0x403402B0" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM013" address="0x403402B4" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM014" address="0x403402B8" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM015" address="0x403402BC" bitWidth="32" desc="Waveform SRAM for half 0 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_OA1_CTRL" address="0x40340300" bitWidth="32" desc="Opamp, comparator, buffer  controls" hidden="false">
        <field name="OA1_PWR" from="2" to="0" access="RW" resetVal="" desc="Opamp1 power level" hidden="false" />
        <field name="CMP1_PWR" from="10" to="8" access="RW" resetVal="" desc="Comparator1 power level" hidden="false" />
        <field name="CMP1_EDGE" from="13" to="12" access="RW" resetVal="" desc="Comparator1 edge detect for interrupt and trigger" hidden="false">
          <value name="DISABLE" value="0" desc="Disabled, no interrupts will be detected" />
          <value name="RISING" value="1" desc="Rising edge" />
          <value name="FALLING" value="10" desc="Falling edge" />
          <value name="BOTH" value="11" desc="Both rising and falling edges" />
        </field>
        <field name="CMP1_DSI_LEVEL" from="14" to="14" access="RW" resetVal="" desc="Comparator trigger out level : 0=pulse, 1=level" hidden="false" />
        <field name="CTRL1_SPARE" from="15" to="15" access="RW" resetVal="" desc="Spare bit" hidden="false" />
        <field name="REF1_PWR" from="18" to="16" access="RW" resetVal="" desc="Reference1 buffer power" hidden="false" />
        <field name="REF1_PTS" from="19" to="19" access="RW" resetVal="" desc="1- Pull the Reference1 buffer output to VDDA" hidden="false" />
        <field name="AGND1_PWR" from="22" to="20" access="RW" resetVal="" desc="Agnd1 buffer power" hidden="false" />
        <field name="AGND1_PTS" from="23" to="23" access="RW" resetVal="" desc="1- Pull the Agnd1 buffer output to VDDA" hidden="false" />
        <field name="SW_RR" from="24" to="24" access="RW" resetVal="" desc="Connect outputs of Reference0 and Reference1 buffer, one buffer must be off.&#xA;This is to drive both UAB halves with the same buffer, so both halves get the same offset noise." hidden="false" />
        <field name="SPARE1_EN" from="25" to="25" access="RW" resetVal="" desc="1 - Enable the spare reference" hidden="false" />
        <field name="H1_PWR" from="31" to="30" access="RW" resetVal="" desc="UAB Half, power profile" hidden="false">
          <value name="NORMAL" value="0" desc="Normal, for normal analog clock speeds" />
          <value name="ULTRA_LOW" value="1" desc="Ultra low power, only allowed for lower analog clock speeds" />
          <value name="ULTRA_HIGH" value="10" desc="Ultra high performance, for higher analog clock speeds (also ultra high power)" />
          <value name="Reserved" value="11" desc="Reserved, do not use" />
        </field>
      </register>
      <register name="UAB_CAP_CTRL1" address="0x40340304" bitWidth="32" desc="Capacitance controls" hidden="false">
        <field name="CB1_GND" from="5" to="5" access="RW" resetVal="" desc="Ground unused caps of CB1 array&#xA;0: leave unused caps floating&#xA;1: ground unused caps (typical when attentuation Cap is used, e.g. for VDAC use-case)" hidden="false" />
        <field name="CC1_GND" from="6" to="6" access="RW" resetVal="" desc="Ground unused caps of CC1 array&#xA;0: leave unused caps floating&#xA;1: ground unused caps (typical when attentuation Cap is used)" hidden="false" />
        <field name="FRC1_SIGN_BIT" from="28" to="28" access="RW" resetVal="" desc="Forces the sign bit to be 1 in DAC mode.  This is used to achieve &#xA;0 - AGND1 range for unsigned numbers using DAC mode 2" hidden="false" />
        <field name="DAC1_MODE_EN" from="29" to="29" access="RW" resetVal="" desc="1: SIGN1_VAL is dedicated sign bit (FW modbit source tied to 0)                                                           0: SIGN1_VAL can be programmed to be a modbit source" hidden="false" />
        <field name="DAC1_MODE" from="31" to="30" access="RW" resetVal="" desc="DAC mode, this determines the AB Cap Value decoding" hidden="false">
          <value name="UNSIGNED12" value="0" desc="Off or Unsigned 12-bit VDAC, i.e. no AB Cap value decoding.&#xA;SIGN1_VAL can be used as Firmware controlled modbit (e.g. to invert the Voltage for a Sign + Magnitude VDAC)" />
          <value name="VIRT_SIGNED12" value="1" desc="Virtual signed 12-bits' VDAC. AB Cap value decoding: &#xA;add 0x800 to the 12-bit AB Cap Value (=invert MSB), to convert the lowest signed number 0x800 to the lowest unsigned number 0x000. This is the same as the SAR handles 12-bit 'virtual' signed numbers." />
          <value name="SIGNED13" value="10" desc="Signed 13-bit twos complement. AB Cap value decoding: &#xA;for negative values (SIGN1_VAL=1) the AB Cap values are inverted, the 64th B cap unit is enabled and the Voltage should be inverted.&#xA;- Voltage inversion only works if the right clocking waveforms, switch settings and reference voltages are used.&#xA;- Enabling the 64th B cap unit adds 1 so that only a AB Cap value inversion is needed to create a true twos complement.  ." />
          <value name="RESERVED" value="11" desc="" />
        </field>
      </register>
      <register name="UAB_CAP_ABCF1_VAL" address="0x40340308" bitWidth="32" desc="Capacitance values for CA1, CB1, CC1 and CF1" hidden="false">
        <field name="CB1_VAL" from="5" to="0" access="RW" resetVal="" desc="Cap B1 Value, in DAC_MODE 1 and 2 this value is decoded" hidden="false" />
        <field name="CA1_VAL" from="11" to="6" access="RW" resetVal="" desc="Cap A1 Value, in DAC_MODE 1 and 2 this value is decoded" hidden="false" />
        <field name="SIGN1_VAL" from="12" to="12" access="RW" resetVal="" desc="Sign bit Value, when used in DAC_MODE, otherwise Firmware modbit.&#xA;In DAC_MODE the modbit should be used to invert the voltage on the AB Caps for the negative DAC values." hidden="false" />
        <field name="CB1_64" from="13" to="13" access="RW" resetVal="" desc="Enable 64th Cap of CB1 array. In DAC mode the FW setting is overridden by the hardware based on DAC_MODE setting.                                                           1 - Enables the 64th cap. This will also set CB1_val[5:0] to be 6'h3F" hidden="false" />
        <field name="CC1_VAL" from="21" to="16" access="RW" resetVal="" desc="Cap C1 Value" hidden="false" />
        <field name="CF1_VAL" from="28" to="24" access="RW" resetVal="" desc="Cap F1 Value" hidden="false" />
      </register>
      <register name="UAB_CAP_AB1_VAL_NXT" address="0x4034030C" bitWidth="32" desc="Next capacitance values for CA1 and CB1" hidden="false">
        <field name="CB1_VAL" from="5" to="0" access="RW" resetVal="" desc="Cap B1 Value" hidden="false" />
        <field name="CA1_VAL" from="11" to="6" access="RW" resetVal="" desc="Cap A1 Value" hidden="false" />
        <field name="SIGN1_VAL" from="12" to="12" access="RW" resetVal="" desc="Sign bit Value" hidden="false" />
      </register>
      <register name="UAB_CAP_CF1_VAL_NXT" address="0x40340310" bitWidth="32" desc="Next capacitance values for CC1 and CF1" hidden="false">
        <field name="CC1_VAL" from="21" to="16" access="RW" resetVal="" desc="Cap C1 Value" hidden="false" />
        <field name="CF1_VAL" from="28" to="24" access="RW" resetVal="" desc="Cap F1 Value" hidden="false" />
        <field name="CC1_VAL_UPDATE" from="30" to="30" access="RW" resetVal="" desc="1 - Update the CC1 cap value with CAP_CC1_VAL_NXT.CC1_VAL" hidden="false" />
        <field name="CF1_VAL_UPDATE" from="31" to="31" access="RW" resetVal="" desc="1 - Update the CF1 cap value with CAP_CF1_VAL_NXT.CF1_VAL" hidden="false" />
      </register>
      <register name="UAB_STARTUP_DELAY1" address="0x40340320" bitWidth="32" desc="Startup delay" hidden="false">
        <field name="STARTUP_DELAY" from="15" to="0" access="RW" resetVal="" desc="Startup delay to synchronize the UAB-SAR interface. The usage and meaning of this field depends on the value of the ALIGN_MODE bit (below).   A value of 0 disables this function." hidden="false" />
        <field name="ALIGN_MODE" from="16" to="16" access="RW" resetVal="" desc="0 - STARTUP_DELAY is number of clk_hf clocks to delay the UAB clock after a SAR Trigger for UAB-SAR alignment in scheduled mode&#xA;1 - STARTUP_DELAY is number of clk_hf clocks to delay UAB trigger to SAR for UAB-SAR alignment in unscheduled mode" hidden="false" />
      </register>
      <register name="UAB_SUBSAMPLE_CTRL1" address="0x40340324" bitWidth="32" desc="Subsample control" hidden="false">
        <field name="SUBSAMPLE" from="7" to="0" access="RW" resetVal="" desc="Subsampling: suppress Valid output during the first SUBSAMPLE analog clock periods. Only allow Valid output in the last of the SUBSAMPLE+1 analog clock periods.&#xA;A value of 0 will not suppress Valid output." hidden="false" />
        <field name="SUBSAMPLE_INIT" from="15" to="8" access="RW" resetVal="" desc="Initial value of the subsampling down counter. Before this UAB half is running the firmware can write to this field the initial value of the subsample down counter. It is recommend that the following is true for the initial value  SUBSAMPLE_INIT&lt;=SUBSAMPLE, however this is not a requirement. Writing a bigger value can be used to postpone the very first Valid output." hidden="false" />
      </register>
      <register name="UAB_SW_STATIC1" address="0x40340330" bitWidth="32" desc="Static switches for half 1 of the UAB" hidden="false">
        <field name="SW_G10" from="0" to="0" access="RW" resetVal="" desc="VIN10 to OA1.vplus (AG1)" hidden="false" />
        <field name="SW_G11" from="1" to="1" access="RW" resetVal="" desc="VIN11 to OA1.vplus (AG1)" hidden="false" />
        <field name="SW_G12" from="2" to="2" access="RW" resetVal="" desc="VIN12 to OA1.vplus (AG1)" hidden="false" />
        <field name="SW_G13" from="3" to="3" access="RW" resetVal="" desc="VIN13 to OA1.vplus (AG1)" hidden="false" />
        <field name="SW_R1G" from="4" to="4" access="RW" resetVal="" desc="REF1 to OA1.vplus (AG1)" hidden="false" />
        <field name="SW_G1G" from="5" to="5" access="RW" resetVal="" desc="AGND1 to OA1.vplus (AG1)" hidden="false" />
        <field name="SW_R1T" from="8" to="8" access="RW" resetVal="" desc="REF1 to cmp1.vminus (Threshold)" hidden="false" />
        <field name="SW_G1T" from="9" to="9" access="RW" resetVal="" desc="AGND1 to cmp1.vminus (Threshold)" hidden="false" />
        <field name="SW_P1T" from="10" to="10" access="RW" resetVal="" desc="OUT0 to cmp1.vminus (Threshold)" hidden="false" />
        <field name="EARLY_Q1S" from="12" to="12" access="RW" resetVal="" desc="OUT1 to Sum1 switch timing: 0=Regular, 1=Early" hidden="false" />
        <field name="EARLY_Q1O" from="13" to="13" access="RW" resetVal="" desc="OUT1 to VOUT1 switch timing: 0=Regular, 1=Early" hidden="false" />
        <field name="RMB1_BITS" from="19" to="16" access="RW" resetVal="" desc="Risk mitigation bits (To be defined if they are used)" hidden="false" />
        <field name="STRB_RST1_SEL" from="28" to="24" access="RW" resetVal="" desc="Select source either for VDAC strobe or analog-reset to discharge all Caps (Delsig Modulator use-case)&#xA;0 = Decimator0 half 0 analog-reset output&#xA;1 = Decimator0 half 1 analog-reset output&#xA;2 = Decimator1 half 0 analog-reset output&#xA;3 = Decimator1 half 1 analog-reset output&#xA;4 = Decimator2 half 0 analog-reset output&#xA;5 = Decimator2 half 1 analog-reset output&#xA;6 = Decimator3 half 0 analog-reset output&#xA;7 = Decimator3 half 1 analog-reset output&#xA;8-31 = generic trigger input 0-23&#xA;For PASS4B  only values 0-1 and 8-13 are legal." hidden="false" />
        <field name="STRB_RST1_EN" from="29" to="29" access="RW" resetVal="" desc="Enable VDAC strobe or UAB analog-reset:&#xA;0: Use selected source as VDAC strobe for next CA1 and CB1 values&#xA;1: Use selected source as Analog-reset (discharge all Caps)" hidden="false" />
      </register>
      <register name="UAB_SW_MODBIT_SRC1" address="0x40340334" bitWidth="32" desc="Select source of Modbit for A,B and C branches of half 1" hidden="false">
        <field name="MODBIT0_SRC1_SEL" from="4" to="0" access="RW" resetVal="" desc="Select source of modbit for A &amp; B branches&#xA;0=UAB0 half 0 comparator output&#xA;1=UAB0 half 1 comparator output&#xA;2=UAB1 half 0 comparator output&#xA;3=UAB1 half 1 comparator output&#xA;4=UAB2 half 0 comparator output&#xA;5=UAB2 half 1 comparator output&#xA;6=UAB3 half 0 comparator output&#xA;7=UAB3 half 1 comparator output&#xA;8-30 = generic trigger inputs 0-22&#xA;31=SIGN1_VAL, also used as Firmware modbit.&#xA;For PASS4B  only values 0-1 and 8-13 and 31 are legal." hidden="false" />
        <field name="MODBIT1_SRC1_SEL" from="12" to="8" access="RW" resetVal="" desc="Select source of modbit for C branch&#xA;0=UAB0 half 0 comparator output&#xA;1=UAB0 half 1 comparator output&#xA;2=UAB1 half 0 comparator output&#xA;3=UAB1 half 1 comparator output&#xA;4=UAB2 half 0 comparator output&#xA;5=UAB2 half 1 comparator output&#xA;6=UAB3 half 0 comparator output&#xA;7=UAB3 half 1 comparator output&#xA;8-30 = generic trigger inputs 0-22&#xA;31=SIGN1_VAL, also used as Firmware modbit.&#xA;For PASS4B  only values 0-1 and 8-11 and 31 are legal." hidden="false" />
      </register>
      <register name="UAB_SW_CA1_IN0" address="0x40340340" bitWidth="32" desc="Cap A1 input switches set 0" hidden="false">
        <field name="SW_A10_CMP" from="3" to="0" access="RW" resetVal="" desc="VIN10 to Cap A1 input, allows for modbit control" hidden="false" />
        <field name="SW_A11_CMP" from="7" to="4" access="RW" resetVal="" desc="VIN11 to Cap A1 input, allows for modbit control" hidden="false" />
        <field name="SW_A12_CMP" from="11" to="8" access="RW" resetVal="" desc="VIN12 to Cap A1 input, allows for modbit control" hidden="false" />
        <field name="SW_A13_CMP" from="15" to="12" access="RW" resetVal="" desc="VIN13 to Cap A1 input, allows for modbit control" hidden="false" />
        <field name="SW_A1P" from="19" to="16" access="RW" resetVal="" desc="OUT1 to Cap A1 input" hidden="false" />
        <field name="SW_A1Q" from="23" to="20" access="RW" resetVal="" desc="OUT0 to Cap A1 input" hidden="false" />
      </register>
      <register name="UAB_SW_CA1_IN1" address="0x40340344" bitWidth="32" desc="Cap A1 input switches set 1" hidden="false">
        <field name="SW_A1R_CMP" from="7" to="4" access="RW" resetVal="" desc="REF1 to Cap A1 input, allows for modbit control" hidden="false" />
        <field name="SW_A1G_CMP" from="11" to="8" access="RW" resetVal="" desc="AGND1 to Cap A1 input, allows for modbit control" hidden="false" />
        <field name="SW_A1V_CMP" from="15" to="12" access="RW" resetVal="" desc="VSS to Cap A1 input, allows for modbit control" hidden="false" />
      </register>
      <register name="UAB_SW_CA1_TOP" address="0x40340348" bitWidth="32" desc="Cap A1 top plate switches" hidden="false">
        <field name="SW_R1A_CMP" from="3" to="0" access="RW" resetVal="" desc="Cap A1 top plate to REF1, allows for modbit control" hidden="false" />
        <field name="SW_G1A_CMP" from="7" to="4" access="RW" resetVal="" desc="Cap A1 top plate to AGND1, allows for modbit control" hidden="false" />
        <field name="SW_V1A_CMP" from="11" to="8" access="RW" resetVal="" desc="Cap A1 top plate to VSS, allows for modbit control" hidden="false" />
        <field name="SW_S1A" from="19" to="16" access="RW" resetVal="" desc="Cap A1 top plate to SUM1" hidden="false" />
      </register>
      <register name="UAB_SW_CB1_IN0" address="0x40340350" bitWidth="32" desc="Cap B1 input switches set 0" hidden="false">
        <field name="SW_B10_CMP" from="3" to="0" access="RW" resetVal="" desc="VIN10 to Cap B1 input, allows for modbit control" hidden="false" />
        <field name="SW_B11_CMP" from="7" to="4" access="RW" resetVal="" desc="VIN11 to Cap B1 input, allows for modbit control" hidden="false" />
        <field name="SW_B12_CMP" from="11" to="8" access="RW" resetVal="" desc="VIN12 to Cap B1 input, allows for modbit control" hidden="false" />
        <field name="SW_B13_CMP" from="15" to="12" access="RW" resetVal="" desc="VIN13 to Cap B1 input, allows for modbit control" hidden="false" />
        <field name="SW_B1P" from="19" to="16" access="RW" resetVal="" desc="OUT1 to Cap B1 input" hidden="false" />
        <field name="SW_B1Q" from="23" to="20" access="RW" resetVal="" desc="OUT0 to Cap B1 input" hidden="false" />
      </register>
      <register name="UAB_SW_CB1_IN1" address="0x40340354" bitWidth="32" desc="Cap B1 input switches set 1" hidden="false">
        <field name="SW_B1R_CMP" from="7" to="4" access="RW" resetVal="" desc="REF1 to Cap B1 input, allows for modbit control" hidden="false" />
        <field name="SW_B1G_CMP" from="11" to="8" access="RW" resetVal="" desc="AGND1 to Cap B1 input, allows for modbit control" hidden="false" />
        <field name="SW_B1V_CMP" from="15" to="12" access="RW" resetVal="" desc="VSS to Cap B1 input, allows for modbit control" hidden="false" />
      </register>
      <register name="UAB_SW_CB1_TOP" address="0x40340358" bitWidth="32" desc="Cap A1 top plate switches" hidden="false">
        <field name="SW_R1B_CMP" from="3" to="0" access="RW" resetVal="" desc="Cap B1 top plate to REF1, allows for modbit control" hidden="false" />
        <field name="SW_G1B_CMP" from="7" to="4" access="RW" resetVal="" desc="Cap B1 top plate to AGND1, allows for modbit control" hidden="false" />
        <field name="SW_V1B_CMP" from="11" to="8" access="RW" resetVal="" desc="Cap B1 top plate to VSS, allows for modbit control" hidden="false" />
        <field name="SW_T1B" from="15" to="12" access="RW" resetVal="" desc="Cap B1 top plate Trim/Attenuation bypass" hidden="false" />
        <field name="SW_S1B" from="19" to="16" access="RW" resetVal="" desc="Cap B1 top plate to SUM1" hidden="false" />
      </register>
      <register name="UAB_SW_CC1_IN0" address="0x40340360" bitWidth="32" desc="Cap C1 input switches set 0" hidden="false">
        <field name="SW_C10_CMP" from="3" to="0" access="RW" resetVal="" desc="VIN10 to Cap C1 input, allows for modbit control" hidden="false" />
        <field name="SW_C11_CMP" from="7" to="4" access="RW" resetVal="" desc="VIN11 to Cap C1 input, allows for modbit control" hidden="false" />
        <field name="SW_C12_CMP" from="11" to="8" access="RW" resetVal="" desc="VIN12 to Cap C1 input, allows for modbit control" hidden="false" />
        <field name="SW_C13_CMP" from="15" to="12" access="RW" resetVal="" desc="VIN13 to Cap C1 input, allows for modbit control" hidden="false" />
        <field name="SW_C1P" from="19" to="16" access="RW" resetVal="" desc="OUT1 to Cap C1 input" hidden="false" />
        <field name="SW_C1Q" from="23" to="20" access="RW" resetVal="" desc="OUT0 to Cap C1 input" hidden="false" />
      </register>
      <register name="UAB_SW_CC1_IN1" address="0x40340364" bitWidth="32" desc="Cap C1 input switches set 1" hidden="false">
        <field name="SW_C1R_CMP" from="7" to="4" access="RW" resetVal="" desc="REF1 to Cap C1 input, allows for modbit control" hidden="false" />
        <field name="SW_C1G_CMP" from="11" to="8" access="RW" resetVal="" desc="AGND1 to Cap C1 input, allows for modbit control" hidden="false" />
        <field name="SW_C1V_CMP" from="15" to="12" access="RW" resetVal="" desc="VSS to Cap C1 input, allows for modbit control" hidden="false" />
      </register>
      <register name="UAB_SW_CC1_TOP" address="0x40340368" bitWidth="32" desc="Cap A1 top plate switches" hidden="false">
        <field name="SW_R1C_CMP" from="3" to="0" access="RW" resetVal="" desc="Cap C1 top plate to REF1, allows for modbit control" hidden="false" />
        <field name="SW_G1C_CMP" from="7" to="4" access="RW" resetVal="" desc="Cap C1 top plate to AGND1, allows for modbit control" hidden="false" />
        <field name="SW_V1C_CMP" from="11" to="8" access="RW" resetVal="" desc="Cap C1 top plate to VSS, allows for modbit control" hidden="false" />
        <field name="SW_T1C" from="15" to="12" access="RW" resetVal="" desc="Cap C1 top plate Trim/Attenuation bypass" hidden="false" />
        <field name="SW_S1C" from="19" to="16" access="RW" resetVal="" desc="Cap C1 top plate to SUM1" hidden="false" />
        <field name="SW_S01" from="23" to="20" access="RW" resetVal="" desc="Cap C1 top plate to SUM0" hidden="false" />
      </register>
      <register name="UAB_SW_CF1_BOT" address="0x4034036C" bitWidth="32" desc="Cap F1 bottom plate and output switches" hidden="false">
        <field name="SW_G1F" from="3" to="0" access="RW" resetVal="" desc="Cap F1 bottom plate to AGND1" hidden="false" />
        <field name="SW_Q1F" from="7" to="4" access="RW" resetVal="" desc="Cap F1 bottom plate to OUT1" hidden="false" />
        <field name="SW_Q1S" from="11" to="8" access="RW" resetVal="" desc="Cap F bypass, OUT1 to SUM1" hidden="false" />
        <field name="SW_Q1O" from="15" to="12" access="RW" resetVal="" desc="OUT1 to VOUT1" hidden="false" />
      </register>
      <register name="UAB_SW_OTHER1" address="0x40340370" bitWidth="32" desc="Other clocked controls" hidden="false">
        <field name="CMP1_FF" from="3" to="0" access="RW" resetVal="" desc="Clock for Flip-Flop after Comparator 1" hidden="false" />
        <field name="VALID1" from="7" to="4" access="RW" resetVal="" desc="Valid1, output flag to indicated that VOUT1 is valid. The Valid output can be suppressed due to sub-sampling. Note that when sub-sampling is used this clocking waveform is used to decrement the counter (decrement is aligned with the positive edge of this clocking waveform)." hidden="false" />
        <field name="TRIG1_OUT" from="11" to="8" access="RW" resetVal="" desc="Trigger output (for other UABs or SAR)" hidden="false" />
        <field name="STROBE_SW1" from="27" to="24" access="RW" resetVal="" desc="Strobe for dsi_sw_ctrl (modbit) update, dsi_sw_ctrl updates in sync with posedge of this wave. To disable set to 0. To enable update anytime use 15." hidden="false" />
        <field name="STROBE_RST1" from="31" to="28" access="RW" resetVal="" desc="Use the positive edge of the selected clocking waveform to synchronize: &#xA; STRB_RST0_EN=0: Capacitor Value update (Capacitor Strobe)&#xA; STRB_RST0_EN=1: UAB analog-reset update&#xA;Set to 0 to disable both functions. Result undefined for value 15." hidden="false" />
      </register>
      <register name="UAB_SW_BOOST_CTRL1" address="0x40340374" bitWidth="32" desc="Bootstrap clock control" hidden="false">
        <field name="CA1_BOOST" from="3" to="0" access="RW" resetVal="" desc="Clock for boot strap master in A branch" hidden="false" />
        <field name="CB1_BOOST" from="7" to="4" access="RW" resetVal="" desc="Clock for boot strap master in B branch" hidden="false" />
        <field name="CC1_BOOST" from="11" to="8" access="RW" resetVal="" desc="Clock for boot strap master in C branch" hidden="false" />
        <field name="CF1_BOOST" from="15" to="12" access="RW" resetVal="" desc="Clock for boot strap master in F branch" hidden="false" />
        <field name="SUM1_BOOST" from="19" to="16" access="RW" resetVal="" desc="Clock for boot strap master in Summing node branch" hidden="false" />
        <field name="PUMP1_WAVE" from="23" to="20" access="RW" resetVal="" desc="Clock for pump in half1" hidden="false" />
      </register>
      <register name="UAB_SRAM1_CTRL" address="0x40340378" bitWidth="32" desc="SRAM programmed size" hidden="false">
        <field name="LAST_STEP" from="3" to="0" access="RW" resetVal="" desc="Last step of wave programmed in the SRAM" hidden="false" />
        <field name="TRIG_SEL1" from="28" to="24" access="RW" resetVal="" desc="Trigger select&#xA;0=UAB0 half 0 trigger output&#xA;1=UAB0 half 1 trigger output&#xA;2=UAB1 half 0 trigger output&#xA;3=UAB1 half 1 trigger output&#xA;4=UAB2 half 0 trigger output&#xA;5=UAB2 half 1 trigger output&#xA;6=UAB3 half 0 trigger output&#xA;7=UAB3 half 1 trigger output&#xA;8-30 = generic trigger inputs 0-22&#xA;31=SAR trigger output&#xA;For PASS4B  only values 0-1 and 8-13 and 31 are legal." hidden="false" />
        <field name="TRIGGER_EN" from="29" to="29" access="RW" resetVal="" desc="Enable input trigger:&#xA;0: Ignore triggers, start running immediately after setting RUN bit&#xA;1: After RUN bit is set wait for a positive edge on the selected trigger input" hidden="false" />
        <field name="RUN" from="31" to="31" access="RW" resetVal="" desc="Set to start executing the waveform (may need to wait for a trigger). Clear to stop this UAB half. When RUN=0 all dynamic switches are forced open." hidden="false" />
      </register>
      <register name="UAB_STAT1" address="0x4034037C" bitWidth="32" desc="Status Current SRAM counter and comparator" hidden="false">
        <field name="CURR_STEP" from="3" to="0" access="R" resetVal="" desc="Current step executed from the SRAM" hidden="false" />
        <field name="COMP" from="4" to="4" access="R" resetVal="" desc="Current comparator status" hidden="false" />
        <field name="CURR_SUBSAMPLE" from="31" to="24" access="R" resetVal="" desc="Current value of the subsampling down counter. The Valid is suppressed when SUBSAMPLE_CUR!=0." hidden="false" />
      </register>
      <register name="UAB_SRAM10" address="0x40340380" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM11" address="0x40340384" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM12" address="0x40340388" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM13" address="0x4034038C" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM14" address="0x40340390" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM15" address="0x40340394" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM16" address="0x40340398" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM17" address="0x4034039C" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM18" address="0x403403A0" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM19" address="0x403403A4" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM110" address="0x403403A8" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM111" address="0x403403AC" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM112" address="0x403403B0" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM113" address="0x403403B4" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM114" address="0x403403B8" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_SRAM115" address="0x403403BC" bitWidth="32" desc="Waveform SRAM for half 1 of the UAB" hidden="false">
        <field name="WAVE_STEP" from="15" to="0" access="RW" resetVal="" desc="one step of the clocking waveform sequence" hidden="false" />
      </register>
      <register name="UAB_DECM_CTRL" address="0x40340400" bitWidth="32" desc="Global decimator control" hidden="false">
        <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="- 0: Decimator disabled (independent of UAB)&#xA;- 1: Decimator enabled (independent of UAB)" hidden="false" />
      </register>
      <register name="UAB_DC0_CTRL" address="0x40340404" bitWidth="32" desc="decimator0 control" hidden="false">
        <field name="DC0_START" from="0" to="0" access="RW" resetVal="" desc="Start decimator, in incremental mode, this bit is cleared by HW when done. If DSI trigger enable is set then only start after a DSI trigger." hidden="false" />
        <field name="DC0_MODE" from="1" to="1" access="RW" resetVal="" desc="Operation mode&#xA;0: Incremental (one-shot) operation&#xA;1: Continuous operation" hidden="false" />
        <field name="DC0_SEL" from="5" to="4" access="RW" resetVal="" desc="Source select" hidden="false">
          <value name="UAB_H0" value="0" desc="Comparator output from Half0 of this UAB" />
          <value name="UAB_H1" value="1" desc="Comparator output from Half1 of this UAB" />
          <value name="DSI0" value="10" desc="" />
          <value name="DSI1" value="11" desc="" />
        </field>
        <field name="DC0_TYPE" from="7" to="6" access="RW" resetVal="" desc="decimator type (filter order)" hidden="false">
          <value name="SINC1" value="0" desc="first order" />
          <value name="SINC2" value="1" desc="second order" />
          <value name="SINC3" value="10" desc="third order, this uses half of decimator1, therefore cannot be combined with dc1_mode SINC2" />
          <value name="reserved" value="11" desc="reserved value, do not use" />
        </field>
        <field name="DC0_SHIFT" from="12" to="8" access="RW" resetVal="" desc="shift the result right by specified amount, legal range 0..16" hidden="false" />
        <field name="DC0_RATIO" from="24" to="16" access="RW" resetVal="" desc="decimation ratio = DC0_RATIO+1, range 1..512" hidden="false" />
      </register>
      <register name="UAB_DC0_TRIG" address="0x40340408" bitWidth="32" desc="decimator0 trigger control" hidden="false">
        <field name="DC0_TRIG_SEL" from="28" to="24" access="RW" resetVal="" desc="Trigger select&#xA;0=UAB0 half 0 trigger output&#xA;1=UAB0 half 1 trigger output&#xA;2=UAB1 half 0 trigger output&#xA;3=UAB1 half 1 trigger output&#xA;4=UAB2 half 0 trigger output&#xA;5=UAB2 half 1 trigger output&#xA;6=UAB3 half 0 trigger output&#xA;7=UAB3 half 1 trigger output&#xA;8-30 = generic trigger inputs 0-22&#xA;31=SAR trigger output&#xA;For PASS4B  only values 0-1 and 8-11 and 31 are legal." hidden="false" />
        <field name="DC0_DSI_TRIG_EN" from="29" to="29" access="RW" resetVal="" desc="Decimator DSI trigger input Enable&#xA;0: Ignore decimator DSI trigger input&#xA;1: Wait for positive edge on selected DSI trigger input" hidden="false" />
      </register>
      <register name="UAB_DC0_OVR" address="0x4034040C" bitWidth="32" desc="decimator 0 overflow control" hidden="false">
        <field name="DC0_OVR_CORR_LOC" from="4" to="0" access="RW" resetVal="" desc="Bit location for overflow correction. This should be set to FILTER_ORDER*log2(DC0_RATIO)" hidden="false" />
      </register>
      <register name="UAB_DC0_A0" address="0x40340410" bitWidth="32" desc="decimator0 accumulator 0" hidden="false">
        <field name="A0" from="31" to="0" access="R" resetVal="" desc="24-bit sign extended accumulator0 status" hidden="false" />
      </register>
      <register name="UAB_DC0_A1" address="0x40340414" bitWidth="32" desc="decimator0 accumulator 1" hidden="false">
        <field name="A1" from="31" to="0" access="R" resetVal="" desc="24-bit sign extended accumulator1 status" hidden="false" />
      </register>
      <register name="UAB_DC0_DEC_CNT" address="0x40340418" bitWidth="32" desc="decimator0 decimation counter" hidden="false">
        <field name="INT_CNT" from="8" to="0" access="R" resetVal="" desc="integration/decimation down counter" hidden="false" />
        <field name="DIFF_CNT" from="17" to="16" access="R" resetVal="" desc="differentiation down counter" hidden="false" />
      </register>
      <register name="UAB_DC0_TMP" address="0x4034041C" bitWidth="32" desc="decimator0 temporary value for differentiator" hidden="false">
        <field name="TMP" from="31" to="0" access="R" resetVal="" desc="24-bit sign extended differentiator temporary value status" hidden="false" />
      </register>
      <register name="UAB_DC0_D0" address="0x40340420" bitWidth="32" desc="decimator0 differentiator 0" hidden="false">
        <field name="D0" from="31" to="0" access="R" resetVal="" desc="24-bit sign extended differentiator 0 status" hidden="false" />
      </register>
      <register name="UAB_DC0_D1" address="0x40340424" bitWidth="32" desc="decimator0 differentiator 1" hidden="false">
        <field name="D1" from="31" to="0" access="R" resetVal="" desc="24-bit sign extended differentiator 1 status" hidden="false" />
      </register>
      <register name="UAB_DC0_RES" address="0x40340428" bitWidth="32" desc="decimator0 result" hidden="false">
        <field name="RES" from="31" to="0" access="R" resetVal="" desc="24-bit sign extended result" hidden="false" />
      </register>
      <register name="UAB_DC1_CTRL" address="0x40340434" bitWidth="32" desc="decimator1 control" hidden="false">
        <field name="DC1_START" from="0" to="0" access="RW" resetVal="" desc="Start decimator, in incremental mode, this bit is cleared by HW when done. If DSI trigger enable is set then only start after a DSI trigger." hidden="false" />
        <field name="DC1_MODE" from="1" to="1" access="RW" resetVal="" desc="Operation mode&#xA;0: Incremental (one-shot) operation&#xA;1: Continuous operation" hidden="false" />
        <field name="DC1_SEL" from="5" to="4" access="RW" resetVal="" desc="Source select" hidden="false">
          <value name="UAB_H0" value="0" desc="Comparator output from Half0 of this UAB" />
          <value name="UAB_H1" value="1" desc="Comparator output from Half1 of this UAB" />
          <value name="DSI0" value="10" desc="" />
          <value name="DSI1" value="11" desc="" />
        </field>
        <field name="DC1_TYPE" from="6" to="6" access="RW" resetVal="" desc="decimator type (filter order)" hidden="false">
          <value name="SINC1" value="0" desc="first order" />
          <value name="SINC2" value="1" desc="second order" />
        </field>
        <field name="DC01_CHAIN" from="7" to="7" access="RW" resetVal="" desc="Chain decimator0 and decimator1" hidden="false" />
        <field name="DC1_SHIFT" from="12" to="8" access="RW" resetVal="" desc="shift the result right by specified amount, legal range 0..16" hidden="false" />
        <field name="DC1_RATIO" from="24" to="16" access="RW" resetVal="" desc="decimation ratio = DC1_RATIO+1, range 1..512" hidden="false" />
      </register>
      <register name="UAB_DC1_TRIG" address="0x40340438" bitWidth="32" desc="decimator1 trigger control" hidden="false">
        <field name="DC1_TRIG_SEL" from="28" to="24" access="RW" resetVal="" desc="Trigger select&#xA;0=UAB0 half 0 trigger output&#xA;1=UAB0 half 1 trigger output&#xA;2=UAB1 half 0 trigger output&#xA;3=UAB1 half 1 trigger output&#xA;4=UAB2 half 0 trigger output&#xA;5=UAB2 half 1 trigger output&#xA;6=UAB3 half 0 trigger output&#xA;7=UAB3 half 1 trigger output&#xA;8-30 = generic trigger inputs 0-22&#xA;31=SAR trigger output&#xA;For PASS4B  only values 0-1 and 8-11 and 31 are legal." hidden="false" />
        <field name="DC1_DSI_TRIG_EN" from="29" to="29" access="RW" resetVal="" desc="Decimator DSI trigger input Enable&#xA;0: Ignore decimator DSI trigger input&#xA;1: Wait for positive edge on selected DSI trigger input" hidden="false" />
      </register>
      <register name="UAB_DC1_OVR" address="0x4034043C" bitWidth="32" desc="decimator 1 overflow control" hidden="false">
        <field name="DC1_OVR_CORR_LOC" from="4" to="0" access="RW" resetVal="" desc="Bit location for overflow correction. This should be set to FILTER_ORDER*log2(DC1_RATIO)" hidden="false" />
      </register>
      <register name="UAB_DC1_A0" address="0x40340440" bitWidth="32" desc="decimator1 accumulator 0" hidden="false">
        <field name="A0" from="31" to="0" access="R" resetVal="" desc="27-bit sign extended accumulator0 status" hidden="false" />
      </register>
      <register name="UAB_DC1_A1" address="0x40340444" bitWidth="32" desc="decimator1 accumulator 1" hidden="false">
        <field name="A1" from="31" to="0" access="R" resetVal="" desc="27-bit sign extended accumulator1 status" hidden="false" />
      </register>
      <register name="UAB_DC1_DEC_CNT" address="0x40340448" bitWidth="32" desc="decimator1 decimation counter" hidden="false">
        <field name="INT_CNT" from="8" to="0" access="R" resetVal="" desc="integration/decimation down counter" hidden="false" />
        <field name="DIFF_CNT" from="17" to="16" access="R" resetVal="" desc="differentiation down counter" hidden="false" />
      </register>
      <register name="UAB_DC1_TMP" address="0x4034044C" bitWidth="32" desc="decimator1 temporary value for differentiator" hidden="false">
        <field name="TMP" from="31" to="0" access="R" resetVal="" desc="27-bit sign extended differentiator temporary value status" hidden="false" />
      </register>
      <register name="UAB_DC1_D0" address="0x40340450" bitWidth="32" desc="decimator1 differentiator 0" hidden="false">
        <field name="D0" from="31" to="0" access="R" resetVal="" desc="27-bit sign extended differentiator 0 status" hidden="false" />
      </register>
      <register name="UAB_DC1_D1" address="0x40340454" bitWidth="32" desc="decimator1 differentiator 1" hidden="false">
        <field name="D1" from="31" to="0" access="R" resetVal="" desc="27-bit sign extended differentiator 1 status" hidden="false" />
      </register>
      <register name="UAB_DC1_RES" address="0x40340458" bitWidth="32" desc="decimator1 result" hidden="false">
        <field name="RES" from="31" to="0" access="R" resetVal="" desc="27-bit sign extended result" hidden="false" />
      </register>
      <register name="UAB_CAP_TRIM0" address="0x40340F00" bitWidth="32" desc="Trim for attenuation cap half0" hidden="false">
        <field name="CBTC0_VAL" from="4" to="0" access="RW" resetVal="" desc="Cap B Trim 0 Value&#xA;Trim attenuation cap in branch B for DAC correctness" hidden="false" />
        <field name="CCTC0_VAL" from="10" to="8" access="RW" resetVal="" desc="Cap C Trim 0 Value&#xA;Do not measure value, instead use same value as for CBTC0_VAL" hidden="false" />
      </register>
      <register name="UAB_CAP_TRIM1" address="0x40340F04" bitWidth="32" desc="Trim for attenuation cap half1" hidden="false">
        <field name="CBTC1_VAL" from="4" to="0" access="RW" resetVal="" desc="Cap B Trim 1 Value&#xA;Trim attenuation cap in branch B for DAC correctness" hidden="false" />
        <field name="CCTC1_VAL" from="10" to="8" access="RW" resetVal="" desc="Cap C Trim 1 Value&#xA;Do not measure value, instead use same value as for CBTC1_VAL" hidden="false" />
      </register>
      <register name="UAB_OA_TRIM0" address="0x40340F08" bitWidth="32" desc="Trim for opamp and buffers half0" hidden="false">
        <field name="OA0_OFFSET" from="3" to="0" access="RW" resetVal="" desc="Opamp offset trim" hidden="false" />
        <field name="REF0_OFFSET" from="12" to="8" access="RW" resetVal="" desc="Reference buffer offset trim" hidden="false" />
        <field name="AGND0_OFFSET" from="20" to="16" access="RW" resetVal="" desc="Agnd buffer offset trim" hidden="false" />
      </register>
      <register name="UAB_OA_TRIM1" address="0x40340F0C" bitWidth="32" desc="Trim for opamp and buffers half1" hidden="false">
        <field name="OA1_OFFSET" from="3" to="0" access="RW" resetVal="" desc="Opamp offset trim" hidden="false" />
        <field name="REF1_OFFSET" from="12" to="8" access="RW" resetVal="" desc="Reference buffer offset trim" hidden="false" />
        <field name="AGND1_OFFSET" from="20" to="16" access="RW" resetVal="" desc="Agnd buffer offset trim" hidden="false" />
      </register>
    </block>
    <block name="VDAC_OUTBUFFER" BASE="0x0" SIZE="0x0" desc="OpAmp" visible="true" hidden="false">
      <block name="cy_analog_noconnect_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
      <block name="cy_analog_virtualmux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
      <block name="cy_analog_virtualmux_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
      <block name="cy_psoc4_abuf" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
      <register name="CTB_CTRL" address="0x40310000" bitWidth="32" desc="Global CTB IP and power control" hidden="false">
        <field name="DEEPSLEEP_ON" from="30" to="30" access="RW" resetVal="" desc="Selects component behavior in DeepSleep power mode" hidden="false">
          <value name="DISABLE" value="0" desc="CTB IP disabled off during DeepSleep power mode" />
          <value name="ENABLE" value="1" desc="CTB IP remains enabled during DeepSleep power mode (if ENABLED=1)" />
        </field>
        <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Selects component behavior in DeepSleep power mode" hidden="false">
          <value name="DISABLE" value="0" desc="CTB IP disabled (put analog in power down, open all switches)" />
          <value name="ENABLE" value="1" desc="CTB IP enabledCTB IP enabled" />
        </field>
      </register>
      <register name="OA_RES_CTRL" address="0x40310004" bitWidth="32" desc="Opamp and resistor control" hidden="false">
        <field name="OA_PWR_MODE" from="1" to="0" access="RW" resetVal="" desc="Selects power for opamp" hidden="false">
          <value name="OFF" value="00" desc="Off" />
          <value name="LOW" value="01" desc="Low power" />
          <value name="MED" value="10" desc="Medium power" />
          <value name="HIGH" value="11" desc="High power" />
        </field>
        <field name="OA0_DRIVE_STR_SEL" from="2" to="2" access="RW" resetVal="" desc="Opamp output strenght select" hidden="false">
          <value name="1x" value="0" desc="Internal only" />
          <value name="10x" value="1" desc="Output to pin" />
        </field>
        <field name="OA_PUMP_EN" from="11" to="11" access="RW" resetVal="" desc="Selects pump" hidden="false">
          <value name="DISABLE" value="0" desc="Pump disabled" />
          <value name="ENABLE" value="1" desc="Pump enabled" />
        </field>
      </register>
      <register name="OA_COMP_TRIM" address="0x40310F08" bitWidth="32" desc="Opamp Compenation Capacitor Trim" hidden="false">
        <field name="OA_COMP_TRIM" from="1" to="0" access="RW" resetVal="" desc="Opamp Compenation Capacitor Trim" hidden="false">
          <value name="HIGH_SPEED" value="01" desc="High Speed" />
          <value name="BALANCED" value="10" desc="Balanced" />
          <value name="HIGH_STABILITY" value="11" desc="High Stability" />
        </field>
      </register>
    </block>
    <block name="cy_constant_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_constant_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="or_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vRef_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="VirtualMux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_virtualmux_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_virtualmux_4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_5" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_virtualmux_5" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="internalClock" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  </block>
  <block name="Opamp_ALS1" BASE="0x0" SIZE="0x0" desc="OpAmp" visible="true" hidden="false">
    <block name="cy_analog_noconnect_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_virtualmux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_virtualmux_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_psoc4_abuf" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <register name="CTB_CTRL" address="0x40300000" bitWidth="32" desc="Global CTB IP and power control" hidden="false">
      <field name="DEEPSLEEP_ON" from="30" to="30" access="RW" resetVal="" desc="Selects component behavior in DeepSleep power mode" hidden="false">
        <value name="DISABLE" value="0" desc="CTB IP disabled off during DeepSleep power mode" />
        <value name="ENABLE" value="1" desc="CTB IP remains enabled during DeepSleep power mode (if ENABLED=1)" />
      </field>
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Selects component behavior in DeepSleep power mode" hidden="false">
        <value name="DISABLE" value="0" desc="CTB IP disabled (put analog in power down, open all switches)" />
        <value name="ENABLE" value="1" desc="CTB IP enabledCTB IP enabled" />
      </field>
    </register>
    <register name="OA_RES_CTRL" address="0x40300008" bitWidth="32" desc="Opamp and resistor control" hidden="false">
      <field name="OA_PWR_MODE" from="1" to="0" access="RW" resetVal="" desc="Selects power for opamp" hidden="false">
        <value name="OFF" value="00" desc="Off" />
        <value name="LOW" value="01" desc="Low power" />
        <value name="MED" value="10" desc="Medium power" />
        <value name="HIGH" value="11" desc="High power" />
      </field>
      <field name="OA0_DRIVE_STR_SEL" from="2" to="2" access="RW" resetVal="" desc="Opamp output strenght select" hidden="false">
        <value name="1x" value="0" desc="Internal only" />
        <value name="10x" value="1" desc="Output to pin" />
      </field>
      <field name="OA_PUMP_EN" from="11" to="11" access="RW" resetVal="" desc="Selects pump" hidden="false">
        <value name="DISABLE" value="0" desc="Pump disabled" />
        <value name="ENABLE" value="1" desc="Pump enabled" />
      </field>
    </register>
    <register name="OA_COMP_TRIM" address="0x40300F14" bitWidth="32" desc="Opamp Compenation Capacitor Trim" hidden="false">
      <field name="OA_COMP_TRIM" from="1" to="0" access="RW" resetVal="" desc="Opamp Compenation Capacitor Trim" hidden="false">
        <value name="HIGH_SPEED" value="01" desc="High Speed" />
        <value name="BALANCED" value="10" desc="Balanced" />
        <value name="HIGH_STABILITY" value="11" desc="High Stability" />
      </field>
    </register>
  </block>
  <block name="Opamp_ALS2" BASE="0x0" SIZE="0x0" desc="OpAmp" visible="true" hidden="false">
    <block name="cy_analog_noconnect_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_virtualmux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_virtualmux_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_psoc4_abuf" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <register name="CTB_CTRL" address="0x40300000" bitWidth="32" desc="Global CTB IP and power control" hidden="false">
      <field name="DEEPSLEEP_ON" from="30" to="30" access="RW" resetVal="" desc="Selects component behavior in DeepSleep power mode" hidden="false">
        <value name="DISABLE" value="0" desc="CTB IP disabled off during DeepSleep power mode" />
        <value name="ENABLE" value="1" desc="CTB IP remains enabled during DeepSleep power mode (if ENABLED=1)" />
      </field>
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Selects component behavior in DeepSleep power mode" hidden="false">
        <value name="DISABLE" value="0" desc="CTB IP disabled (put analog in power down, open all switches)" />
        <value name="ENABLE" value="1" desc="CTB IP enabledCTB IP enabled" />
      </field>
    </register>
    <register name="OA_RES_CTRL" address="0x40300004" bitWidth="32" desc="Opamp and resistor control" hidden="false">
      <field name="OA_PWR_MODE" from="1" to="0" access="RW" resetVal="" desc="Selects power for opamp" hidden="false">
        <value name="OFF" value="00" desc="Off" />
        <value name="LOW" value="01" desc="Low power" />
        <value name="MED" value="10" desc="Medium power" />
        <value name="HIGH" value="11" desc="High power" />
      </field>
      <field name="OA0_DRIVE_STR_SEL" from="2" to="2" access="RW" resetVal="" desc="Opamp output strenght select" hidden="false">
        <value name="1x" value="0" desc="Internal only" />
        <value name="10x" value="1" desc="Output to pin" />
      </field>
      <field name="OA_PUMP_EN" from="11" to="11" access="RW" resetVal="" desc="Selects pump" hidden="false">
        <value name="DISABLE" value="0" desc="Pump disabled" />
        <value name="ENABLE" value="1" desc="Pump enabled" />
      </field>
    </register>
    <register name="OA_COMP_TRIM" address="0x40300F08" bitWidth="32" desc="Opamp Compenation Capacitor Trim" hidden="false">
      <field name="OA_COMP_TRIM" from="1" to="0" access="RW" resetVal="" desc="Opamp Compenation Capacitor Trim" hidden="false">
        <value name="HIGH_SPEED" value="01" desc="High Speed" />
        <value name="BALANCED" value="10" desc="Balanced" />
        <value name="HIGH_STABILITY" value="11" desc="High Stability" />
      </field>
    </register>
  </block>
  <block name="R_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="THERM_REF_LO" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="PVref_ALS" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false">
    <block name="cy_psoc4_pref" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  </block>
  <block name="POT_A2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="TIA_IN" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="TIA_OUT_A0" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="Opamp_Therm" BASE="0x0" SIZE="0x0" desc="OpAmp" visible="true" hidden="false">
    <block name="cy_analog_noconnect_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_virtualmux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_virtualmux_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_psoc4_abuf" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <register name="CTB_CTRL" address="0x40310000" bitWidth="32" desc="Global CTB IP and power control" hidden="false">
      <field name="DEEPSLEEP_ON" from="30" to="30" access="RW" resetVal="" desc="Selects component behavior in DeepSleep power mode" hidden="false">
        <value name="DISABLE" value="0" desc="CTB IP disabled off during DeepSleep power mode" />
        <value name="ENABLE" value="1" desc="CTB IP remains enabled during DeepSleep power mode (if ENABLED=1)" />
      </field>
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="Selects component behavior in DeepSleep power mode" hidden="false">
        <value name="DISABLE" value="0" desc="CTB IP disabled (put analog in power down, open all switches)" />
        <value name="ENABLE" value="1" desc="CTB IP enabledCTB IP enabled" />
      </field>
    </register>
    <register name="OA_RES_CTRL" address="0x40310008" bitWidth="32" desc="Opamp and resistor control" hidden="false">
      <field name="OA_PWR_MODE" from="1" to="0" access="RW" resetVal="" desc="Selects power for opamp" hidden="false">
        <value name="OFF" value="00" desc="Off" />
        <value name="LOW" value="01" desc="Low power" />
        <value name="MED" value="10" desc="Medium power" />
        <value name="HIGH" value="11" desc="High power" />
      </field>
      <field name="OA0_DRIVE_STR_SEL" from="2" to="2" access="RW" resetVal="" desc="Opamp output strenght select" hidden="false">
        <value name="1x" value="0" desc="Internal only" />
        <value name="10x" value="1" desc="Output to pin" />
      </field>
      <field name="OA_PUMP_EN" from="11" to="11" access="RW" resetVal="" desc="Selects pump" hidden="false">
        <value name="DISABLE" value="0" desc="Pump disabled" />
        <value name="ENABLE" value="1" desc="Pump enabled" />
      </field>
    </register>
    <register name="OA_COMP_TRIM" address="0x40310F14" bitWidth="32" desc="Opamp Compenation Capacitor Trim" hidden="false">
      <field name="OA_COMP_TRIM" from="1" to="0" access="RW" resetVal="" desc="Opamp Compenation Capacitor Trim" hidden="false">
        <value name="HIGH_SPEED" value="01" desc="High Speed" />
        <value name="BALANCED" value="10" desc="Balanced" />
        <value name="HIGH_STABILITY" value="11" desc="High Stability" />
      </field>
    </register>
  </block>
  <block name="ADC" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false">
    <block name="Bypass" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_70" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="intSarClock" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_8" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="aclkMux" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_7" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="extVrefMux" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="socMux" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="or_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vrefMux_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_72" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vrefMux_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_73" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vrefMux_0" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_9" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vrefMux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_71" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_65" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinNegMux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinNegConnect" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinNegMux_0" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_67" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinNegMux_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_66" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinNegMux_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vplusMux" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_6" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_5" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_psoc4_sar_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vminusMux" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_74" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_11" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_10" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_13" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_12" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_7" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_6" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_9" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_8" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_14" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_20" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_19" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_22" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_21" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_16" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_15" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_18" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_17" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="filterConfigMux_0" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="filterConfigMux_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="filterVinMux_3_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="filterVinMux_3_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_0" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="IRQ" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="filterConfigMux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="filterConfigMux_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="filterVinMux_3_0" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_5" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="filterVinMux_2_0" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="filterVinMux_2_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="filterVinMux_1_0" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_42" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_42" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_43" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_43" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_40" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_40" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_41" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_41" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_44" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_47" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_46" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_48" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_47" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_45" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_44" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_46" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_45" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_34" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_33" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_35" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_34" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_32" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_31" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_33" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_32" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_35" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_38" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_38" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_39" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_39" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_36" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_36" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_37" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_37" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_48" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_60" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_59" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_61" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_60" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_58" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_57" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_59" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_58" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_61" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusConnect" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_64" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_68" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_psoc4_sarmux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_62" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_62" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_63" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_63" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_51" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_51" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_52" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_52" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_49" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_49" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_50" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_50" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_53" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_56" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_55" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_57" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_56" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_54" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_53" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_55" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_54" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_36" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_35" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_38" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_37" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_31" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_30" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_34" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_33" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_39" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_45" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_44" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_47" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_46" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_41" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_40" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_43" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_42" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_18" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_17" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_20" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_19" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_14" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_13" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_16" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_15" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_21" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_27" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_26" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_29" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_28" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_23" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_22" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_25" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_24" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_48" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vssa_kelvin_0" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vssa_kelvin_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_87" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vrefMuxRemoved" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vRef_7" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vRef_6" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vssa_kelvin_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vssa_kelvin_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="intermbc" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_84" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_83" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_86" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_85" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="agndbc" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_81" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_82" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_80" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_54" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_53" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_56" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_55" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_50" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_49" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_52" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_51" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_57" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_63" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_62" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vRef_5" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vRef_4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_59" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_58" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_61" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_60" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_32" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_17" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_33" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_32" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_14" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_13" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_16" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_15" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_34" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_40" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_39" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_42" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_41" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_36" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_35" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_38" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_37" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_28" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_27" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_30" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_29" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_24" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_23" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_26" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_25" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_31" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_10" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_78" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_12" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="ZeroTerminal_11" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_75" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_69" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_77" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_76" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_43" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_0" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_62" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_61" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="intUabClock" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_63" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_10" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_9" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_12" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_11" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_6" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_5" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_8" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinMinusMux_7" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_49" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_48" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_51" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_50" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_45" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_44" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_47" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_46" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_52" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_58" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_57" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_60" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_59" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_54" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_53" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_56" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="sarmuxVinPlusMux_55" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusConnect" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_31" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_164" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_163" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_162" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_30" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_32" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_34" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_167" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_166" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_165" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_33" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_29" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_25" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_158" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_157" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_156" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_24" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_26" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_28" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_161" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_160" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_159" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_27" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_35" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_43" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_176" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_175" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_174" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_42" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_44" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_46" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_179" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_178" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_177" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_45" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_41" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_37" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_170" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_169" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_168" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_36" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_38" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_40" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_173" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_172" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_171" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_39" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_23" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_7" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_140" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_139" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_138" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_6" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_8" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_10" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_143" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_142" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_141" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_9" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_5" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_134" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_133" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_31" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_0" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_137" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_136" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_135" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_11" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_19" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_152" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_151" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_150" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_18" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_20" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_22" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_155" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_154" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_153" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_21" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_17" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_13" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_146" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_145" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_144" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_12" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_14" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_16" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_149" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_148" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_147" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_15" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_15" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_15" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_14" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_13" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_14" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_16" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_18" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_18" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_17" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_16" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_17" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_13" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_9" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_9" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_8" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_7" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_8" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_10" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_12" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_12" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_11" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_10" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_11" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_19" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_27" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_27" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_26" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_25" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_26" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_28" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_30" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_30" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_29" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_28" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_29" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_25" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_21" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_21" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_20" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_19" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_20" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_22" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_24" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_24" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_23" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_22" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_23" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_7" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_187" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_55" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_54" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_53" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_186" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_188" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_190" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_58" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_57" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_56" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_189" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_185" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_181" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_49" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_48" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_47" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_180" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_182" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_184" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_52" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_51" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_50" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_183" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_191" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_3" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_2" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_6" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_6" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_5" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_4" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_5" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_193" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_61" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_60" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_59" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_192" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_194" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_196" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinMinusMux_0" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_63" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="vinPlusMux_62" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <block name="cy_analog_noconnect_195" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
    <register name="ADC_CTRL" address="0x403A0000" bitWidth="32" desc="Analog control register." hidden="false">
      <field name="VREF_SEL" from="6" to="4" access="RW" resetVal="" desc="SARADC internal VREF selection." hidden="false">
        <value name="VREF0" value="0" desc="VREF0 from PRB (VREF buffer on)" />
        <value name="VREF1" value="1" desc="VREF1 from PRB (VREF buffer on)" />
        <value name="VREF2" value="10" desc="VREF2 from PRB (VREF buffer on)" />
        <value name="VREF_AROUTE" value="11" desc="VREF from AROUTE (VREF buffer on)" />
        <value name="VBGR" value="100" desc="1.024V from BandGap (VREF buffer on)" />
        <value name="VREF_EXT" value="101" desc="External precision Vref direct from a pin (low impedance path)." />
        <value name="VDDA_DIV_2" value="110" desc="Vdda/2  (VREF buffer on)" />
        <value name="VDDA" value="111" desc="Vdda." />
      </field>
      <field name="VREF_BYP_CAP_EN" from="7" to="7" access="RW" resetVal="" desc="VREF bypass cap enable for when VREF buffer is on" hidden="false" />
      <field name="NEG_SEL" from="11" to="9" access="RW" resetVal="" desc="SARADC internal NEG selection for Single ended conversion" hidden="false">
        <value name="VSSA_KELVIN" value="0" desc="NEG input of SARADC is connected to &quot;vssa_kelvin&quot;, gives more precision around zero. Note this opens both SARADC internal switches, therefore use this value to insert a break-before-make cycle on those switches when SWITCH_DISABLE is high." />
        <value name="ART_VSSA" value="1" desc="NEG input of SARADC is connected to VSSA in AROUTE close to the SARADC" />
        <value name="P1" value="10" desc="NEG input of SARADC is connected to P1 pin of SARMUX" />
        <value name="P3" value="11" desc="NEG input of SARADC is connected to P3 pin of SARMUX" />
        <value name="P5" value="100" desc="NEG input of SARADC is connected to P5 pin of SARMUX" />
        <value name="P7" value="101" desc="NEG input of SARADC is connected to P7 pin of SARMUX" />
        <value name="ACORE" value="110" desc="NEG input of SARADC is connected to an ACORE in AROUTE" />
        <value name="VREF" value="111" desc="NEG input of SARADC is shorted with VREF input of SARADC." />
      </field>
      <field name="SAR_HW_CTRL_NEGVREF" from="13" to="13" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for VREF to NEG switch." hidden="false" />
      <field name="PWR_CTRL_VREF" from="15" to="14" access="RW" resetVal="" desc="VREF buffer low power mode." hidden="false">
        <value name="NORMAL_PWR" value="0" desc="normal power (default), bypass cap, max clk_sar is 18MHz." />
        <value name="HALF_PWR" value="1" desc="deprecated" />
        <value name="THIRD_PWR" value="10" desc="Invalid for PSoC4A, otherwise 2X power, no bypass cap, max clk_sar is 1.8MHz" />
        <value name="QUARTER_PWR" value="11" desc="deprecated" />
      </field>
      <field name="SPARE" from="19" to="16" access="RW" resetVal="" desc="Spare controls, not yet designated, for late changes done with an ECO" hidden="false" />
      <field name="BOOSTPUMP_EN" from="20" to="20" access="RW" resetVal="" desc="SARADC internal pump: 0=disabled: pump output is VDDA, 1=enabled: pump output is boosted." hidden="false" />
      <field name="REFBUF_EN" from="21" to="21" access="RW" resetVal="" desc="1 - Enable the SARREFBUF. This bit needs to be set when SAR is enabled and needs reference buffer." hidden="false" />
      <field name="ICONT_LV" from="25" to="24" access="RW" resetVal="" desc="SARADC low power mode." hidden="false">
        <value name="NORMAL_PWR" value="0" desc="normal power (default), max clk_sar is 18MHz." />
        <value name="HALF_PWR" value="1" desc="1/2 power mode, max clk_sar is 9MHz." />
        <value name="MORE_PWR" value="10" desc="1.333 power mode, max clk_sar is 18MHz." />
        <value name="QUARTER_PWR" value="11" desc="1/4 power mode, max clk_sar is 4.5MHz." />
      </field>
      <field name="DEEPSLEEP_ON" from="27" to="27" access="RW" resetVal="" desc="- 0: SARMUX IP disabled off during DeepSleep power mode&#xA;- 1: SARMUX IP remains enabled during DeepSleep power mode (if ENABLED=1)" hidden="false" />
      <field name="DSI_SYNC_CONFIG" from="28" to="28" access="RW" resetVal="" desc="- 0: bypass clock domain synchronisation of the DSI config signals.&#xA;- 1: synchronize the DSI config signals to peripheral clock domain." hidden="false" />
      <field name="DSI_MODE" from="29" to="29" access="RW" resetVal="" desc="SAR sequencer takes configuration from DSI signals (note this also has the same effect as SWITCH_DISABLE==1)&#xA;- 0: Normal mode, SAR sequencer operates according to CHAN_EN enables and CHAN_CONFIG channel configurations&#xA;- 1: CHAN_EN, INJ_START_EN and channel configurations in CHAN_CONFIG and INJ_CHAN_CONFIG are ignored" hidden="false" />
      <field name="SWITCH_DISABLE" from="30" to="30" access="RW" resetVal="" desc="Disable SAR sequencer from enabling routing switches (note DSI and firmware can always close switches independent of this control)&#xA;- 0: Normal mode, SAR sequencer changes switches according to pin address in channel configurations&#xA;- 1: Switches disabled, SAR sequencer does not enable any switches, it is the responsibility of the firmware or UDBs (through DSI) to set the switches to route the signal to be converted through the SARMUX" hidden="false" />
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="- 0: SAR IP disabled (put analog in power down and stop clocks), also can clear FW_TRIGGER and INJ_START_EN (if not tailgaiting) on write.&#xA;- 1: SAR IP enabled." hidden="false" />
    </register>
    <register name="ADC_SAMPLE_CTRL" address="0x403A0004" bitWidth="32" desc="Sample control register." hidden="false">
      <field name="SUB_RESOLUTION" from="0" to="0" access="RW" resetVal="" desc="Conversion resolution for channels that have sub-resolution enabled (RESOLUTION=1) (otherwise resolution is 12-bit)." hidden="false">
        <value name="8B" value="0" desc="8-bit." />
        <value name="10B" value="1" desc="10-bit." />
      </field>
      <field name="LEFT_ALIGN" from="1" to="1" access="RW" resetVal="" desc="Left align data in data[15:0], default data is right aligned in data[11:0], with sign extension to 16 bits if the channel is differential." hidden="false" />
      <field name="SINGLE_ENDED_SIGNED" from="2" to="2" access="RW" resetVal="" desc="Output data from a single ended conversion as a signed value" hidden="false">
        <value name="UNSIGNED" value="0" desc="Default: result data is unsigned (zero extended if needed)" />
        <value name="SIGNED" value="1" desc="result data is signed (sign extended if needed)" />
      </field>
      <field name="DIFFERENTIAL_SIGNED" from="3" to="3" access="RW" resetVal="" desc="Output data from a differential conversion as a signed value when DIFFERENTIAL_EN or NEG_ADDR_EN is set to 1" hidden="false">
        <value name="UNSIGNED" value="0" desc="result data is unsigned (zero extended if needed)" />
        <value name="SIGNED" value="1" desc="Default: result data is signed (sign extended if needed)" />
      </field>
      <field name="AVG_CNT" from="6" to="4" access="RW" resetVal="" desc="Averaging Count for channels that have averaging enabled (AVG_EN). A channel will be sampled (1&lt;&lt;(AVG_CNT+1)) = [2..256] times.&#xA;- In ACCUNDUMP mode  (1st order accumulate and dump filter) a channel will be sampled back to back, the average result is calculated and stored and then the next enabled channel is sampled. If shifting is not enabled (AVG_SHIFT=0) then the result is forced to shift right so that is fits in 16 bits, so right shift is done by max(0,AVG_CNT-3).&#xA;- In INTERLEAVED mode one sample is taken per triggered scan, only in the scan where the final averaging count is reached a valid average is calculated and stored in the RESULT register (by definition the same scan for all the channels that have averaging enabled). In all other scans the RESULT register for averaged channels will have an invalid result and the intermediate accumulated value is stored in the 16-bit WORK register. In this mode make sure that the averaging count is low enough to ensure that the intermediate value does not exceed 16-bits otherwise the MSBs will be lost. So for a 12-bit resolution the averaging count should be set to 16 or less (AVG_CNT=&lt;3)." hidden="false" />
      <field name="AVG_SHIFT" from="7" to="7" access="RW" resetVal="" desc="Averaging shifting: after averaging the result is shifted right to fit in the sample resolution. For averaging the sample resolution is the highest resolution allowed by wounding." hidden="false" />
      <field name="AVG_MODE" from="8" to="8" access="RW" resetVal="" desc="Averaging mode,  in DSI mode this bit is ignored and only AccuNDump mode is available." hidden="false">
        <value name="ACCUNDUMP" value="0" desc="Accumulate and Dump (1st order accumulate and dump filter): a channel will be sampled back to back and averaged" />
        <value name="INTERLEAVED" value="1" desc="Interleaved: Each scan (trigger) one sample is taken per channel and averaged over several scans." />
      </field>
      <field name="CONTINUOUS" from="16" to="16" access="RW" resetVal="" desc="- 0: Wait for next FW_TRIGGER (one shot) or hardware (DSI) trigger (e.g. from TPWM for periodic triggering) before scanning enabled channels.&#xA;- 1: Continuously scan enabled channels, ignore triggers." hidden="false" />
      <field name="DSI_TRIGGER_EN" from="17" to="17" access="RW" resetVal="" desc="- 0: firmware trigger only: disable hardware (DSI) trigger.&#xA;- 1: enable hardware (DSI) trigger (e.g. from TCPWM, GPIO or UDB)." hidden="false" />
      <field name="DSI_TRIGGER_LEVEL" from="18" to="18" access="RW" resetVal="" desc="- 0: DSI trigger signal is a pulse input, a positive edge detected on the DSI trigger signal triggers a new scan.&#xA;- 1: DSI trigger signal is a level input, as long as the DSI trigger signal remains high the SAR will do continuous scans." hidden="false" />
      <field name="DSI_SYNC_TRIGGER" from="19" to="19" access="RW" resetVal="" desc="- 0: bypass clock domain synchronisation of the DSI trigger signal.&#xA;- 1: synchronize the DSI trigger signal to the SAR clock domain, if needed an edge detect is done in the peripheral clock domain." hidden="false" />
      <field name="UAB_SCAN_MODE" from="22" to="22" access="RW" resetVal="" desc="Select whether UABs are scheduled or unscheduled. When no UAB is scanned this selection is ignored." hidden="false">
        <value name="UNSCHEDULED" value="0" desc="Unscheduled UABs: one or more of the UABs scanned by the SAR is not scheduled, for each channel that scans a UAB the SAR will wait for a positive edge on the trigger output of that UAB. Caveat: in this mode the length of SAR scan can be variable." />
        <value name="SCHEDULED" value="1" desc="Scheduled UABs: All UABs scanned by the SAR are assumed to be properly scheduled, i.e. their output is assumed to be valid when sampled by the SAR and the SAR does not wait. In this mode the length of the SAR scan is constant. &#xA;This mode requires that the SAR scans strictly periodically, i.e. the SAR has to either run continuously or has to be triggered by a periodic hardware trigger (TCPWM or UDB timer). It also requires that the end of the UAB valid phase is precisely aligned with the end of the SAR sample period (using UAB.STARTUP_DELAY). Normally this scheduling is done by Creator." />
      </field>
      <field name="REPEAT_INVALID" from="23" to="23" access="RW" resetVal="" desc="For unscheduled UAB_SCAN_MODE only, do the following if an invalid sample is received:&#xA;- 0: use the last known valid sample for that channel and clear the NEWVALUE flag&#xA;- 1: repeat the conversions until a valid sample is received (caveat: could be never if the UAB valid window is incorrectly schedule w.r.t. SAR sampling)" hidden="false" />
      <field name="VALID_SEL" from="26" to="24" access="RW" resetVal="" desc="Static UAB Valid select&#xA;0=UAB0 half 0 Valid output&#xA;1=UAB0 half 1 Valid output&#xA;2=UAB1 half 0 Valid output&#xA;3=UAB1 half 1 Valid output&#xA;4=UAB2 half 0 Valid output&#xA;5=UAB2 half 1 Valid output&#xA;6=UAB3 half 0 Valid output&#xA;7=UAB3 half 1 Valid output" hidden="false" />
      <field name="VALID_SEL_EN" from="27" to="27" access="RW" resetVal="" desc="Enable static UAB Valid selection (override Hardware)" hidden="false" />
      <field name="VALID_IGNORE" from="28" to="28" access="RW" resetVal="" desc="Ignore UAB valid signal, including the dynamic/Hardware from AROUTE and the static Valid selection from the VALID_SEL fields above" hidden="false" />
      <field name="TRIGGER_OUT_EN" from="30" to="30" access="RW" resetVal="" desc="SAR output trigger enable (used for UAB synchronization). To ensure multiple UABs starting at the same trigger it is recommended to use this bit to temporarily disable the trigger output until all those UABs are set to run (UAB.SRAM_CTRL.RUN=1)." hidden="false" />
      <field name="EOS_DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="Enable to output EOS_INTR to DSI. When enabled each time EOS_INTR is set by the hardware also a pulse is send on the dsi_eos signal." hidden="false" />
    </register>
    <register name="ADC_SAMPLE_TIME01" address="0x403A0010" bitWidth="32" desc="Sample time specification ST0 and ST1" hidden="false">
      <field name="SAMPLE_TIME0" from="9" to="0" access="RW" resetVal="" desc="Sample time0 (aperture) in ADC clock cycles. Note that actual sample time is half a clock less than specified here. The minimum sample time is 194ns, which is 3.5 cycles (4 in this field) with an 18MHz clock. Minimum legal value in this register is 2." hidden="false" />
      <field name="SAMPLE_TIME1" from="25" to="16" access="RW" resetVal="" desc="Sample time1" hidden="false" />
    </register>
    <register name="ADC_SAMPLE_TIME23" address="0x403A0014" bitWidth="32" desc="Sample time specification ST2 and ST3" hidden="false">
      <field name="SAMPLE_TIME2" from="9" to="0" access="RW" resetVal="" desc="Sample time2" hidden="false" />
      <field name="SAMPLE_TIME3" from="25" to="16" access="RW" resetVal="" desc="Sample time3" hidden="false" />
    </register>
    <register name="ADC_RANGE_THRES" address="0x403A0018" bitWidth="32" desc="Global range detect threshold register." hidden="false">
      <field name="RANGE_LOW" from="15" to="0" access="RW" resetVal="" desc="Low threshold for range detect." hidden="false" />
      <field name="RANGE_HIGH" from="31" to="16" access="RW" resetVal="" desc="High threshold for range detect." hidden="false" />
    </register>
    <register name="ADC_RANGE_COND" address="0x403A001C" bitWidth="32" desc="Global range detect mode register." hidden="false">
      <field name="RANGE_COND" from="31" to="30" access="RW" resetVal="" desc="Range condition select." hidden="false">
        <value name="BELOW" value="0" desc="result &lt; RANGE_LOW" />
        <value name="INSIDE" value="1" desc="RANGE_LOW &lt;= result &lt; RANGE_HIGH" />
        <value name="ABOVE" value="10" desc="RANGE_HIGH &lt;= result" />
        <value name="OUTSIDE" value="11" desc="result &lt; RANGE_LOW || RANGE_HIGH &lt;= result" />
      </field>
    </register>
    <register name="ADC_CHAN_EN" address="0x403A0020" bitWidth="32" desc="Enable bits for the channels" hidden="false">
      <field name="CHAN_EN" from="15" to="0" access="RW" resetVal="" desc="Channel enable. &#xA;- 0: the corresponding channel is disabled.&#xA;- 1: the corresponding channel is enabled, it will be included in the next scan." hidden="false" />
    </register>
    <register name="ADC_START_CTRL" address="0x403A0024" bitWidth="32" desc="Start control register (firmware trigger)." hidden="false">
      <field name="FW_TRIGGER" from="0" to="0" access="RW" resetVal="" desc="When firmware writes a 1 here it will trigger the next scan of enabled channels, hardware clears this bit when the scan started with this trigger is completed. If scanning continuously the trigger is ignored and hardware clears this bit after the next scan is done. This bit is also cleared when the SAR is disabled." hidden="false" />
    </register>
    <register name="ADC_DFT_CTRL" address="0x403A0030" bitWidth="32" desc="DFT control register." hidden="false">
      <field name="DLY_INC" from="0" to="0" access="RW" resetVal="" desc="DFT control: Control for delay circuits on sampling phase, =1 doubes the non-overlap delay" hidden="false" />
      <field name="HIZ" from="1" to="1" access="RW" resetVal="" desc="DFT control for getting higher input impedance, must be 1 (0 is deprecated)" hidden="false" />
      <field name="DFT_INC" from="19" to="16" access="RW" resetVal="" desc="DFT control for preamp inputs" hidden="false" />
      <field name="DFT_OUTC" from="22" to="20" access="RW" resetVal="" desc="DFT control for preamp outputs" hidden="false" />
      <field name="SEL_CSEL_DFT" from="27" to="24" access="RW" resetVal="" desc="Usage 1: DFT bits for DAC array&#xA;Usage 2: For [0]=1 (when dcen=0): Delay timing for latch enable increased by 20%&#xA;[1]=1: comparator preamp power level increased by 25%" hidden="false" />
      <field name="EN_CSEL_DFT" from="28" to="28" access="RW" resetVal="" desc="Mux select signal for DAC control" hidden="false" />
      <field name="DCEN" from="29" to="29" access="RW" resetVal="" desc="Delay Control Enable for latch.&#xA;- 0: doubles the latch enable time.&#xA;- 1: normal latch enable time." hidden="false" />
      <field name="ADFT_OVERRIDE" from="31" to="31" access="RW" resetVal="" desc="During deepsleep/ hibernate mode keep SARMUX active, i.e. do not open all switches (disconnect), to be used for ADFT" hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG0" address="0x403A0080" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG1" address="0x403A0084" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG2" address="0x403A0088" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG3" address="0x403A008C" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG4" address="0x403A0090" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG5" address="0x403A0094" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG6" address="0x403A0098" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG7" address="0x403A009C" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG8" address="0x403A00A0" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG9" address="0x403A00A4" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG10" address="0x403A00A8" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG11" address="0x403A00AC" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG12" address="0x403A00B0" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG13" address="0x403A00B4" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG14" address="0x403A00B8" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_CONFIG15" address="0x403A00BC" bitWidth="32" desc="Channel configuration register." hidden="false">
      <field name="POS_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this channel (connected to Vplus)" hidden="false" />
      <field name="POS_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel (connected to Vplus)" hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port (VPORT0)" />
      </field>
      <field name="DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel." hidden="false">
        <value name="MAXRES" value="0" desc="The maximum resolution is used for this channel (maximum resolution depends on wounding)." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="NEG_PIN_ADDR" from="18" to="16" access="RW" resetVal="" desc="Address of the neg pin to be sampled by this channel." hidden="false" />
      <field name="NEG_PORT_ADDR" from="22" to="20" access="RW" resetVal="" desc="Address of the neg port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="AROUTE_VIRT2" value="101" desc="AROUTE virtual port2 (VPORT2)" />
        <value name="AROUTE_VIRT1" value="110" desc="AROUTE virtual port1 (VPORT1)" />
        <value name="RESERVED1" value="111" desc="Unused fields" />
      </field>
      <field name="NEG_ADDR_EN" from="24" to="24" access="RW" resetVal="" desc="1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin." hidden="false" />
      <field name="DSI_OUT_EN" from="31" to="31" access="RW" resetVal="" desc="DSI data output enable for this channel.&#xA;- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.&#xA;- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs." hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK0" address="0x403A0100" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK1" address="0x403A0104" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK2" address="0x403A0108" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK3" address="0x403A010C" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK4" address="0x403A0110" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK5" address="0x403A0114" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK6" address="0x403A0118" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK7" address="0x403A011C" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK8" address="0x403A0120" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK9" address="0x403A0124" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK10" address="0x403A0128" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK11" address="0x403A012C" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK12" address="0x403A0130" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK13" address="0x403A0134" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK14" address="0x403A0138" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK15" address="0x403A013C" bitWidth="32" desc="Channel working data register" hidden="false">
      <field name="WORK" from="15" to="0" access="R" resetVal="" desc="SAR conversion working data of the channel. The data is written here right after sampling this channel." hidden="false" />
      <field name="CHAN_WORK_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register" hidden="false" />
      <field name="CHAN_WORK_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT0" address="0x403A0180" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT1" address="0x403A0184" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT2" address="0x403A0188" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT3" address="0x403A018C" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT4" address="0x403A0190" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_HAN_RESULT5" address="0x403A0194" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT6" address="0x403A0198" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT7" address="0x403A019C" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT8" address="0x403A01A0" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT9" address="0x403A01A4" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT10" address="0x403A01A8" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT11" address="0x403A01AC" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT12" address="0x403A01B0" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT13" address="0x403A01B4" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT14" address="0x403A01B8" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT15" address="0x403A01BC" bitWidth="32" desc="Channel result data register" hidden="false">
      <field name="RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled." hidden="false" />
      <field name="CHAN_RESULT_NEWVALUE_MIR" from="27" to="27" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register" hidden="false" />
      <field name="SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_SATURATE_INTR register" hidden="false" />
      <field name="RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_RANGE_INTR register" hidden="false" />
      <field name="CHAN_RESULT_UPDATED_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register" hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK_UPDATED" address="0x403A0200" bitWidth="32" desc="Channel working data register 'updated' bits" hidden="false">
      <field name="CHAN_WORK_UPDATED" from="15" to="0" access="R" resetVal="" desc="If set the corresponding WORK register was updated, i.e. was already sampled during the current scan and, in case of Interleaved averaging, reached the averaging count. If this bit is low then either the channel is not enabled or the averaging count is not yet reached for Interleaved averaging." hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT_UPDATED" address="0x403A0204" bitWidth="32" desc="Channel result data register 'updated' bits" hidden="false">
      <field name="CHAN_RESULT_UPDATED" from="15" to="0" access="R" resetVal="" desc="If set the corresponding RESULT register was updated, i.e. was sampled during the previous scan and, in case of Interleaved averaging, reached the averaging count. If this bit is low then either the channel is not enabled or the averaging count is not yet reached for Interleaved averaging." hidden="false" />
    </register>
    <register name="ADC_CHAN_WORK_NEWVALUE" address="0x403A0208" bitWidth="32" desc="Channel working data register 'new value' bits" hidden="false">
      <field name="CHAN_WORK_NEWVALUE" from="15" to="0" access="R" resetVal="" desc="If set the corresponding WORK data received a new value, i.e. was already sampled during the current scan and data was valid.&#xA;In case of  a UAB this New Value bit reflects the value of UAB.valid output, for anything else the data is always valid.&#xA;In case of averaging this New Value bit is an OR of all the valid bits received by each conversion." hidden="false" />
    </register>
    <register name="ADC_CHAN_RESULT_NEWVALUE" address="0x403A020C" bitWidth="32" desc="Channel result data register 'new value' bits" hidden="false">
      <field name="CHAN_RESULT_NEWVALUE" from="15" to="0" access="R" resetVal="" desc="If set the corresponding RESULT data received a new value, i.e. was sampled during the last scan and data was valid.&#xA;In case of  a UAB this New Value bit reflects the value of UAB.valid output, for anything else the data is always valid.&#xA;In case of averaging this New Value bit is an OR of all the valid bits received by each conversion." hidden="false" />
    </register>
    <register name="ADC_INTR" address="0x403A0210" bitWidth="32" desc="Interrupt request register." hidden="false">
      <field name="EOS_INTR" from="0" to="0" access="RW" resetVal="" desc="End Of Scan Interrupt: hardware sets this interrupt after completing a scan of all the enabled channels. Write with '1' to clear bit." hidden="false" />
      <field name="OVERFLOW_INTR" from="1" to="1" access="RW" resetVal="" desc="Overflow Interrupt: hardware sets this interrupt when it sets a new EOS_INTR while that bit was not yet cleared by the firmware. Write with '1' to clear bit." hidden="false" />
      <field name="FW_COLLISION_INTR" from="2" to="2" access="RW" resetVal="" desc="Firmware Collision Interrupt: hardware sets this interrupt when FW_TRIGGER is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the FW_TRIGGER has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit." hidden="false" />
      <field name="DSI_COLLISION_INTR" from="3" to="3" access="RW" resetVal="" desc="DSI Collision Interrupt: hardware sets this interrupt when the DSI trigger signal is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the DSI trigger has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit." hidden="false" />
      <field name="INJ_EOC_INTR" from="4" to="4" access="RW" resetVal="" desc="Injection End of Conversion Interrupt: hardware sets this interrupt after completing the conversion for the injection channel (irrespective of if tailgating was used). Write with '1' to clear bit." hidden="false" />
      <field name="INJ_SATURATE_INTR" from="5" to="5" access="RW" resetVal="" desc="Injection Saturation Interrupt: hardware sets this interrupt if an injection conversion result (before averaging) is either 0x000 or 0xFFF (for 12-bit resolution), this is an indication that the ADC likely saturated. Write with '1' to clear bit." hidden="false" />
      <field name="INJ_RANGE_INTR" from="6" to="6" access="RW" resetVal="" desc="Injection Range detect Interrupt: hardware sets this interrupt if the injection conversion result (after averaging) met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit." hidden="false" />
      <field name="INJ_COLLISION_INTR" from="7" to="7" access="RW" resetVal="" desc="Injection Collision Interrupt: hardware sets this interrupt when the injection trigger signal is asserted (INJ_START_EN==1 &amp;&amp; INJ_TAILGATING==0) while the SAR is BUSY. Raising this interrupt is delayed to when the sampling of the injection channel has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the injection channel was sampled later than was intended. Write with '1' to clear bit." hidden="false" />
    </register>
    <register name="ADC_INTR_SET" address="0x403A0214" bitWidth="32" desc="Interrupt set request register" hidden="false">
      <field name="EOS_SET" from="0" to="0" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="OVERFLOW_SET" from="1" to="1" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="FW_COLLISION_SET" from="2" to="2" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="DSI_COLLISION_SET" from="3" to="3" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="INJ_EOC_SET" from="4" to="4" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="INJ_SATURATE_SET" from="5" to="5" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="INJ_RANGE_SET" from="6" to="6" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
      <field name="INJ_COLLISION_SET" from="7" to="7" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="ADC_INTR_MASK" address="0x403A0218" bitWidth="32" desc="Interrupt mask register." hidden="false">
      <field name="EOS_MASK" from="0" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="OVERFLOW_MASK" from="1" to="1" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="FW_COLLISION_MASK" from="2" to="2" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="DSI_COLLISION_MASK" from="3" to="3" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="INJ_EOC_MASK" from="4" to="4" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="INJ_SATURATE_MASK" from="5" to="5" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="INJ_RANGE_MASK" from="6" to="6" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
      <field name="INJ_COLLISION_MASK" from="7" to="7" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="ADC_INTR_MASKED" address="0x403A021C" bitWidth="32" desc="Interrupt masked request register" hidden="false">
      <field name="EOS_MASKED" from="0" to="0" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="OVERFLOW_MASKED" from="1" to="1" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="FW_COLLISION_MASKED" from="2" to="2" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="DSI_COLLISION_MASKED" from="3" to="3" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="INJ_EOC_MASKED" from="4" to="4" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="INJ_SATURATE_MASKED" from="5" to="5" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="INJ_RANGE_MASKED" from="6" to="6" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
      <field name="INJ_COLLISION_MASKED" from="7" to="7" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
    </register>
    <register name="ADC_SATURATE_INTR" address="0x403A0220" bitWidth="32" desc="Saturate interrupt request register." hidden="false">
      <field name="SATURATE_INTR" from="15" to="0" access="RW" resetVal="" desc="Saturate Interrupt: hardware sets this interrupt for each channel if a conversion result (before averaging) of that channel is either 0x000 or 0xFFF (for 12-bit resolution), this is an indication that the ADC likely saturated. Write with '1' to clear bit." hidden="false" />
    </register>
    <register name="ADC_SATURATE_INTR_SET" address="0x403A0224" bitWidth="32" desc="Saturate interrupt set request register" hidden="false">
      <field name="SATURATE_SET" from="15" to="0" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="ADC_SATURATE_INTR_MASK" address="0x403A0228" bitWidth="32" desc="Saturate interrupt mask register." hidden="false">
      <field name="SATURATE_MASK" from="15" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="ADC_SATURATE_INTR_MASKED" address="0x403A022C" bitWidth="32" desc="Saturate interrupt masked request register" hidden="false">
      <field name="SATURATE_MASKED" from="15" to="0" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
    </register>
    <register name="ADC_RANGE_INTR" address="0x403A0230" bitWidth="32" desc="Range detect interrupt request register." hidden="false">
      <field name="RANGE_INTR" from="15" to="0" access="RW" resetVal="" desc="Range detect Interrupt: hardware sets this interrupt for each channel if the conversion result (after averaging) of that channel met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit." hidden="false" />
    </register>
    <register name="ADC_RANGE_INTR_SET" address="0x403A0234" bitWidth="32" desc="Range detect interrupt set request register" hidden="false">
      <field name="RANGE_SET" from="15" to="0" access="RW" resetVal="" desc="Write with '1' to set corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="ADC_RANGE_INTR_MASK" address="0x403A0238" bitWidth="32" desc="Range detect interrupt mask register." hidden="false">
      <field name="RANGE_MASK" from="15" to="0" access="RW" resetVal="" desc="Mask bit for corresponding bit in interrupt request register." hidden="false" />
    </register>
    <register name="ADC_RANGE_INTR_MASKED" address="0x403A023C" bitWidth="32" desc="Range interrupt masked request register" hidden="false">
      <field name="RANGE_MASKED" from="15" to="0" access="R" resetVal="" desc="Logical and of corresponding request and mask bits." hidden="false" />
    </register>
    <register name="ADC_INTR_CAUSE" address="0x403A0240" bitWidth="32" desc="Interrupt cause register" hidden="false">
      <field name="EOS_MASKED_MIR" from="0" to="0" access="R" resetVal="" desc="Mirror copy of corresponding bit in SAR_INTR_MASKED" hidden="false" />
      <field name="OVERFLOW_MASKED_MIR" from="1" to="1" access="R" resetVal="" desc="Mirror copy of corresponding bit in SAR_INTR_MASKED" hidden="false" />
      <field name="FW_COLLISION_MASKED_MIR" from="2" to="2" access="R" resetVal="" desc="Mirror copy of corresponding bit in SAR_INTR_MASKED" hidden="false" />
      <field name="DSI_COLLISION_MASKED_MIR" from="3" to="3" access="R" resetVal="" desc="Mirror copy of corresponding bit in SAR_INTR_MASKED" hidden="false" />
      <field name="INJ_EOC_MASKED_MIR" from="4" to="4" access="R" resetVal="" desc="Mirror copy of corresponding bit in SAR_INTR_MASKED" hidden="false" />
      <field name="INJ_SATURATE_MASKED_MIR" from="5" to="5" access="R" resetVal="" desc="Mirror copy of corresponding bit in SAR_INTR_MASKED" hidden="false" />
      <field name="INJ_RANGE_MASKED_MIR" from="6" to="6" access="R" resetVal="" desc="Mirror copy of corresponding bit in SAR_INTR_MASKED" hidden="false" />
      <field name="INJ_COLLISION_MASKED_MIR" from="7" to="7" access="R" resetVal="" desc="Mirror copy of corresponding bit in SAR_INTR_MASKED" hidden="false" />
      <field name="SATURATE_MASKED_RED" from="30" to="30" access="R" resetVal="" desc="Reduction OR of all SAR_SATURATION_INTR_MASKED bits" hidden="false" />
      <field name="RANGE_MASKED_RED" from="31" to="31" access="R" resetVal="" desc="Reduction OR of all SAR_RANGE_INTR_MASKED bits" hidden="false" />
    </register>
    <register name="ADC_INJ_CHAN_CONFIG" address="0x403A0280" bitWidth="32" desc="Injection channel configuration register." hidden="false">
      <field name="INJ_PIN_ADDR" from="2" to="0" access="RW" resetVal="" desc="Address of the pin to be sampled by this injection channel. If differential is enabled then INJ_PIN_ADDR[0] is ignored and considered to be 0, i.e. INJ_PIN_ADDR points to the even pin of a pin pair." hidden="false" />
      <field name="INJ_PORT_ADDR" from="6" to="4" access="RW" resetVal="" desc="Address of the port that contains the pin to be sampled by this channel." hidden="false">
        <value name="SARMUX" value="0" desc="SARMUX pins." />
        <value name="CTB0" value="1" desc="CTB0" />
        <value name="CTB1" value="10" desc="CTB1" />
        <value name="CTB2" value="11" desc="CTB2" />
        <value name="CTB3" value="100" desc="CTB3" />
        <value name="AROUTE_VIRT" value="110" desc="AROUTE virtual port" />
        <value name="SARMUX_VIRT" value="111" desc="SARMUX virtual port" />
      </field>
      <field name="INJ_DIFFERENTIAL_EN" from="8" to="8" access="RW" resetVal="" desc="Differential enable for this channel.&#xA;- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.&#xA;- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (INJ_PIN_ADDR[0] is ignored)." hidden="false" />
      <field name="INJ_RESOLUTION" from="9" to="9" access="RW" resetVal="" desc="Resolution for this channel." hidden="false">
        <value name="12B" value="0" desc="12-bit resolution is used for this channel." />
        <value name="SUBRES" value="1" desc="The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel." />
      </field>
      <field name="INJ_AVG_EN" from="10" to="10" access="RW" resetVal="" desc="Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)" hidden="false" />
      <field name="INJ_SAMPLE_TIME_SEL" from="13" to="12" access="RW" resetVal="" desc="Injection sample time select: select which of the 4 global sample times to use for this channel" hidden="false" />
      <field name="INJ_TAILGATING" from="30" to="30" access="RW" resetVal="" desc="Injection channel tailgating.&#xA;- 0: no tailgating for this channel, SAR is immediately triggered when the INJ_START_EN bit is set.&#xA;- 1: injection channel tailgating. The addressed pin is sampled after the next trigger and after all enabled channels have been scanned." hidden="false" />
      <field name="INJ_START_EN" from="31" to="31" access="RW" resetVal="" desc="Set by firmware to enable the injection channel. If INJ_TAILGATING is not set this bit also functions as trigger for this channel. Cleared by hardware after this channel has been sampled (i.e. this channel is always one shot even if CONTINUOUS is set). Also cleared if the SAR is disabled." hidden="false" />
    </register>
    <register name="ADC_INJ_RESULT" address="0x403A0290" bitWidth="32" desc="Injection channel result register" hidden="false">
      <field name="INJ_RESULT" from="15" to="0" access="R" resetVal="" desc="SAR conversion result of the channel." hidden="false" />
      <field name="INJ_NEWVALUE" from="27" to="27" access="R" resetVal="" desc="The data in this register received a new value (only relevant for UAB, this bit shows the value of the UAB valid bit)" hidden="false" />
      <field name="INJ_COLLISION_INTR_MIR" from="28" to="28" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_INTR register" hidden="false" />
      <field name="INJ_SATURATE_INTR_MIR" from="29" to="29" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_INTR register" hidden="false" />
      <field name="INJ_RANGE_INTR_MIR" from="30" to="30" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_INTR register" hidden="false" />
      <field name="INJ_EOC_INTR_MIR" from="31" to="31" access="R" resetVal="" desc="mirror bit of corresponding bit in SAR_INTR register" hidden="false" />
    </register>
    <register name="ADC_STATUS" address="0x403A02A0" bitWidth="32" desc="Current status of internal SAR registers (mostly for debug)" hidden="false">
      <field name="CUR_CHAN" from="4" to="0" access="R" resetVal="" desc="current channel being sampled (channel 16 indicates the injection channel), only valid if BUSY." hidden="false" />
      <field name="SW_VREF_NEG" from="30" to="30" access="R" resetVal="" desc="the current switch status, including DSI and sequencer controls, of the switch in the SARADC that shorts NEG with VREF input (see NEG_SEL)." hidden="false" />
      <field name="BUSY" from="31" to="31" access="R" resetVal="" desc="If high then the SAR is busy with a conversion. This bit is always high when CONTINUOUS is set. Firmware should wait for this bit to be low before putting the SAR in power down." hidden="false" />
    </register>
    <register name="ADC_AVG_STAT" address="0x403A02A4" bitWidth="32" desc="Current averaging status (for debug)" hidden="false">
      <field name="CUR_AVG_ACCU" from="19" to="0" access="R" resetVal="" desc="the current value of the averaging accumulator" hidden="false" />
      <field name="INTRLV_BUSY" from="23" to="23" access="R" resetVal="" desc="If high then the SAR is in the middle of Interleaved averaging spanning several scans. While this bit is high the Firmware should not make any changes to the configuration registers otherwise some results may be incorrect. Note that the CUR_AVG_CNT status register below gives an indication how many more scans need to be done to complete the Interleaved averaging.&#xA;This bit can be cleared by changing the averaging mode to ACCUNDUMP or by disabling the SAR." hidden="false" />
      <field name="CUR_AVG_CNT" from="31" to="24" access="R" resetVal="" desc="the current value of the averaging counter. Note that the value shown is updated after the sampling time and therefore runs ahead of the accumulator update." hidden="false" />
    </register>
    <register name="ADC_MUX_SWITCH0" address="0x403A0300" bitWidth="32" desc="SARMUX Firmware switch controls" hidden="false">
      <field name="MUX_FW_P0_VPLUS" from="0" to="0" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P0 and vplus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P1_VPLUS" from="1" to="1" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P1 and vplus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P2_VPLUS" from="2" to="2" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P2 and vplus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P3_VPLUS" from="3" to="3" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P3 and vplus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P4_VPLUS" from="4" to="4" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P4 and vplus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P5_VPLUS" from="5" to="5" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P5 and vplus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P6_VPLUS" from="6" to="6" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P6 and vplus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P7_VPLUS" from="7" to="7" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P7 and vplus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P0_VMINUS" from="8" to="8" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P0 and vminus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P1_VMINUS" from="9" to="9" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P1 and vminus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P2_VMINUS" from="10" to="10" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P2 and vminus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P3_VMINUS" from="11" to="11" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P3 and vminus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P4_VMINUS" from="12" to="12" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P4 and vminus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P5_VMINUS" from="13" to="13" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P5 and vminus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P6_VMINUS" from="14" to="14" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P6 and vminus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P7_VMINUS" from="15" to="15" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between pin P7 and vminus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_VSSA_VMINUS" from="16" to="16" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between vssa_kelvin and vminus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_TEMP_VPLUS" from="17" to="17" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between temperature sensor and vplus signal, also powers on the temperature sensor. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_AMUXBUSA_VPLUS" from="18" to="18" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between amuxbusa and vplus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_AMUXBUSB_VPLUS" from="19" to="19" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between amuxbusb and vplus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_AMUXBUSA_VMINUS" from="20" to="20" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between amuxbusa and vminus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_AMUXBUSB_VMINUS" from="21" to="21" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between amuxbusb and vminus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_SARBUS0_VPLUS" from="22" to="22" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between sarbus0 and vplus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_SARBUS1_VPLUS" from="23" to="23" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between sarbus1 and vplus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_SARBUS0_VMINUS" from="24" to="24" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between sarbus0 and vminus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_SARBUS1_VMINUS" from="25" to="25" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between sarbus1 and vminus signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P4_COREIO0" from="26" to="26" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between P4 and coreio0 signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P5_COREIO1" from="27" to="27" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between P5 and coreio1 signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P6_COREIO2" from="28" to="28" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between P6 and coreio2 signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P7_COREIO3" from="29" to="29" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between P7 and coreio3 signal. Write with '1' to set bit." hidden="false" />
    </register>
    <register name="ADC_MUX_SWITCH_CLEAR0" address="0x403A0304" bitWidth="32" desc="SARMUX Firmware switch control clear" hidden="false">
      <field name="MUX_FW_P0_VPLUS" from="0" to="0" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P1_VPLUS" from="1" to="1" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P2_VPLUS" from="2" to="2" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P3_VPLUS" from="3" to="3" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P4_VPLUS" from="4" to="4" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P5_VPLUS" from="5" to="5" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P6_VPLUS" from="6" to="6" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P7_VPLUS" from="7" to="7" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P0_VMINUS" from="8" to="8" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P1_VMINUS" from="9" to="9" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P2_VMINUS" from="10" to="10" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P3_VMINUS" from="11" to="11" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P4_VMINUS" from="12" to="12" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P5_VMINUS" from="13" to="13" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P6_VMINUS" from="14" to="14" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P7_VMINUS" from="15" to="15" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_VSSA_VMINUS" from="16" to="16" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_TEMP_VPLUS" from="17" to="17" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_AMUXBUSA_VPLUS" from="18" to="18" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_AMUXBUSB_VPLUS" from="19" to="19" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_AMUXBUSA_VMINUS" from="20" to="20" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_AMUXBUSB_VMINUS" from="21" to="21" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_SARBUS0_VPLUS" from="22" to="22" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_SARBUS1_VPLUS" from="23" to="23" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_SARBUS0_VMINUS" from="24" to="24" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_SARBUS1_VMINUS" from="25" to="25" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P4_COREIO0" from="26" to="26" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P5_COREIO1" from="27" to="27" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P6_COREIO2" from="28" to="28" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P7_COREIO3" from="29" to="29" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH0" hidden="false" />
    </register>
    <register name="ADC_MUX_SWITCH1" address="0x403A0308" bitWidth="32" desc="SARMUX Firmware switch controls" hidden="false">
      <field name="MUX_FW_P4_DFT_INP" from="0" to="0" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between P4 pin and dft_inp signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_P5_DFT_INM" from="1" to="1" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between P5 pin and dft_inm signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_ADFT0_SARBUS0" from="2" to="2" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between adft0 signal and sarbus0 signal. Write with '1' to set bit." hidden="false" />
      <field name="MUX_FW_ADFT1_SARBUS1" from="3" to="3" access="RW" resetVal="" desc="Firmware control: 0=open, 1=close switch between adft1 signal and sarbus1 signal. Write with '1' to set bit." hidden="false" />
    </register>
    <register name="ADC_MUX_SWITCH_CLEAR1" address="0x403A030C" bitWidth="32" desc="SARMUX Firmware switch control clear" hidden="false">
      <field name="MUX_FW_P4_DFT_INP" from="0" to="0" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH1" hidden="false" />
      <field name="MUX_FW_P5_DFT_INM" from="1" to="1" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH1" hidden="false" />
      <field name="MUX_FW_ADFT0_SARBUS0" from="2" to="2" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH1" hidden="false" />
      <field name="MUX_FW_ADFT1_SARBUS1" from="3" to="3" access="RW" resetVal="" desc="Write '1' to clear corresponding bit in MUX_SWITCH1" hidden="false" />
    </register>
    <register name="ADC_MUX_SWITCH_HW_CTRL" address="0x403A0340" bitWidth="32" desc="SARMUX switch hardware control" hidden="false">
      <field name="MUX_HW_CTRL_P0" from="0" to="0" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P0 switches." hidden="false" />
      <field name="MUX_HW_CTRL_P1" from="1" to="1" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P1 switches." hidden="false" />
      <field name="MUX_HW_CTRL_P2" from="2" to="2" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P2 switches." hidden="false" />
      <field name="MUX_HW_CTRL_P3" from="3" to="3" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P3 switches." hidden="false" />
      <field name="MUX_HW_CTRL_P4" from="4" to="4" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P4 switches." hidden="false" />
      <field name="MUX_HW_CTRL_P5" from="5" to="5" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P5 switches." hidden="false" />
      <field name="MUX_HW_CTRL_P6" from="6" to="6" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P6 switches." hidden="false" />
      <field name="MUX_HW_CTRL_P7" from="7" to="7" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P7 switches." hidden="false" />
      <field name="MUX_HW_CTRL_VSSA" from="16" to="16" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for vssa switch." hidden="false" />
      <field name="MUX_HW_CTRL_TEMP" from="17" to="17" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for temp switch." hidden="false" />
      <field name="MUX_HW_CTRL_AMUXBUSA" from="18" to="18" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for amuxbusa switches." hidden="false" />
      <field name="MUX_HW_CTRL_AMUXBUSB" from="19" to="19" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for amuxbusb switches." hidden="false" />
      <field name="MUX_HW_CTRL_SARBUS0" from="22" to="22" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for sarbus0 switches." hidden="false" />
      <field name="MUX_HW_CTRL_SARBUS1" from="23" to="23" access="RW" resetVal="" desc="Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for sarbus1 switches." hidden="false" />
    </register>
    <register name="ADC_MUX_SWITCH_STATUS" address="0x403A0348" bitWidth="32" desc="SARMUX switch status" hidden="false">
      <field name="MUX_FW_P0_VPLUS" from="0" to="0" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P1_VPLUS" from="1" to="1" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P2_VPLUS" from="2" to="2" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P3_VPLUS" from="3" to="3" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P4_VPLUS" from="4" to="4" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P5_VPLUS" from="5" to="5" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P6_VPLUS" from="6" to="6" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P7_VPLUS" from="7" to="7" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P0_VMINUS" from="8" to="8" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P1_VMINUS" from="9" to="9" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P2_VMINUS" from="10" to="10" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P3_VMINUS" from="11" to="11" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P4_VMINUS" from="12" to="12" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P5_VMINUS" from="13" to="13" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P6_VMINUS" from="14" to="14" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_P7_VMINUS" from="15" to="15" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_VSSA_VMINUS" from="16" to="16" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_TEMP_VPLUS" from="17" to="17" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_AMUXBUSA_VPLUS" from="18" to="18" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_AMUXBUSB_VPLUS" from="19" to="19" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_AMUXBUSA_VMINUS" from="20" to="20" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_AMUXBUSB_VMINUS" from="21" to="21" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_SARBUS0_VPLUS" from="22" to="22" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_SARBUS1_VPLUS" from="23" to="23" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_SARBUS0_VMINUS" from="24" to="24" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
      <field name="MUX_FW_SARBUS1_VMINUS" from="25" to="25" access="R" resetVal="" desc="switch status of corresponding bit in MUX_SWITCH0" hidden="false" />
    </register>
    <register name="ADC_PUMP_CTRL" address="0x403A0380" bitWidth="32" desc="Switch pump control" hidden="false">
      <field name="CLOCK_SEL" from="0" to="0" access="RW" resetVal="" desc="Clock select: 0=external clock, 1=internal clock (deprecated)." hidden="false" />
      <field name="ENABLED" from="31" to="31" access="RW" resetVal="" desc="0=disabled: pump output is VDDA_PUMP, 1=enabled: pump output is boosted." hidden="false" />
    </register>
    <register name="ADC_ANA_TRIM" address="0x403A0F00" bitWidth="32" desc="Analog trim register." hidden="false">
      <field name="CAP_TRIM" from="2" to="0" access="RW" resetVal="" desc="Attenuation cap trimming" hidden="false" />
      <field name="TRIMUNIT" from="3" to="3" access="RW" resetVal="" desc="Attenuation cap trimming" hidden="false" />
    </register>
    <register name="ADC_WOUNDING" address="0x403A0F04" bitWidth="32" desc="SAR wounding register" hidden="false">
      <field name="WOUND_RESOLUTION" from="1" to="0" access="RW" resetVal="" desc="Maximum SAR resolution allowed" hidden="false">
        <value name="12BIT" value="0" desc="unwounded: up to full 12-bit SAR resolution allowed" />
        <value name="10BIT" value="1" desc="wounded: max resolution upto 10-bit SAR resolution allowed" />
        <value name="8BIT" value="10" desc="wounded: only 8-bit SAR resolution allowed" />
        <value name="8BIT_TOO" value="11" desc="wounded: only 8-bit SAR resolution allowed" />
      </field>
    </register>
  </block>
  <block name="VDAC_A1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="PVref_Therm" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false">
    <block name="cy_psoc4_pref" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  </block>
  <block name="THERM_REF_MID" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="R_1" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="THERM_BUF" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
  <block name="THERM_REF_HI" BASE="0x0" SIZE="0x0" desc="" visible="true" hidden="false" />
</blockRegMap>